// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name walletverse_ios_sdk
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
import CoreGraphics
import CryptoSwift
import Dispatch
import Foundation
import MBProgressHUD
import MobileCoreServices
import SQLite3
import Swift
import SwiftyJSON
import SystemConfiguration
import UIKit.UIImage
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
@_exported import walletverse_ios_sdk
open class Record : walletverse_ios_sdk.FetchableRecord, walletverse_ios_sdk.TableRecord, walletverse_ios_sdk.PersistableRecord {
  public init()
  required public init(row: walletverse_ios_sdk.Row)
  open class var databaseTableName: Swift.String {
    get
  }
  open class var persistenceConflictPolicy: walletverse_ios_sdk.PersistenceConflictPolicy {
    get
  }
  open class var databaseSelection: [walletverse_ios_sdk.SQLSelectable] {
    get
  }
  open func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
  open func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  open func copy() -> Self
  public var hasDatabaseChanges: Swift.Bool {
    get
    set
  }
  public var databaseChanges: [Swift.String : walletverse_ios_sdk.DatabaseValue?] {
    get
  }
  open func insert(_ db: walletverse_ios_sdk.GDatabase) throws
  open func update(_ db: walletverse_ios_sdk.GDatabase, columns: Swift.Set<Swift.String>) throws
  @discardableResult
  final public func updateChanges(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  final public func save(_ db: walletverse_ios_sdk.GDatabase) throws
  @discardableResult
  open func delete(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  @objc deinit
}
final public class Response : Swift.CustomDebugStringConvertible, Swift.Equatable {
  final public let statusCode: Swift.Int
  final public let data: Foundation.Data
  final public let request: Foundation.URLRequest?
  final public let response: Foundation.HTTPURLResponse?
  public init(statusCode: Swift.Int, data: Foundation.Data, request: Foundation.URLRequest? = nil, response: Foundation.HTTPURLResponse? = nil)
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: walletverse_ios_sdk.Response, rhs: walletverse_ios_sdk.Response) -> Swift.Bool
  @objc deinit
}
extension walletverse_ios_sdk.Response {
  final public func filter<R>(statusCodes: R) throws -> walletverse_ios_sdk.Response where R : Swift.RangeExpression, R.Bound == Swift.Int
  final public func filter(statusCode: Swift.Int) throws -> walletverse_ios_sdk.Response
  final public func filterSuccessfulStatusCodes() throws -> walletverse_ios_sdk.Response
  final public func filterSuccessfulStatusAndRedirectCodes() throws -> walletverse_ios_sdk.Response
  final public func mapImage() throws -> walletverse_ios_sdk.Image
  final public func mapJSON(failsOnEmptyData: Swift.Bool = true) throws -> Any
  final public func mapString(atKeyPath keyPath: Swift.String? = nil) throws -> Swift.String
  final public func map<D>(_ type: D.Type, atKeyPath keyPath: Swift.String? = nil, using decoder: Foundation.JSONDecoder = JSONDecoder(), failsOnEmptyData: Swift.Bool = true) throws -> D where D : Swift.Decodable
}
extension Foundation.NSNumber : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
public func == (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: Swift.Bool) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: Swift.Bool, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func == (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: Swift.Bool) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: Swift.Bool, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func != (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func === (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func === (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func === (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func === (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func === (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func !== (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func !== (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible?) -> walletverse_ios_sdk.SQLExpression
public func !== (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func !== (lhs: walletverse_ios_sdk.SQLExpressible?, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func !== (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func < (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func < (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func < (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func < (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func < (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func <= (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func <= (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func <= (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func <= (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func <= (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func > (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func > (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func > (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func > (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func > (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func >= (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func >= (lhs: walletverse_ios_sdk.SQLCollatedExpression, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func >= (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func >= (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
public func >= (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension Swift.Range where Bound : walletverse_ios_sdk.SQLExpressible {
  public func contains(_ element: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
  public func contains(_ element: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
}
extension Swift.ClosedRange where Bound : walletverse_ios_sdk.SQLExpressible {
  public func contains(_ element: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
  public func contains(_ element: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
}
extension Swift.CountableRange where Bound : Swift.Strideable, Bound : walletverse_ios_sdk.SQLExpressible, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
}
extension Swift.CountableClosedRange where Bound : Swift.Strideable, Bound : walletverse_ios_sdk.SQLExpressible, Bound.Stride : Swift.SignedInteger {
  public func contains(_ element: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
}
extension Swift.Sequence where Self.Element : walletverse_ios_sdk.SQLExpressible {
  public func contains(_ element: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
  public func contains(_ element: walletverse_ios_sdk.SQLCollatedExpression) -> walletverse_ios_sdk.SQLExpression
}
public func * (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func * (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func * (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func / (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func / (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func / (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func + (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func + (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func + (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
prefix public func - (value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func - (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func - (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func - (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func && (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func && (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func && (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func || (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
public func || (lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func || (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
prefix public func ! (value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public enum SQLLogicalBinaryOperator {
  case and, or
  public static func == (a: walletverse_ios_sdk.SQLLogicalBinaryOperator, b: walletverse_ios_sdk.SQLLogicalBinaryOperator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Sequence where Self.Element == walletverse_ios_sdk.SQLExpression {
  public func joined(operator: walletverse_ios_sdk.SQLLogicalBinaryOperator) -> walletverse_ios_sdk.SQLExpression
}
extension walletverse_ios_sdk.SQLSpecificExpressible {
  public func like(_ pattern: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
}
public struct AssociationAggregate<RowDecoder> {
}
extension walletverse_ios_sdk.AssociationAggregate {
  public func aliased(_ name: Swift.String) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
  public func aliased(_ key: Swift.CodingKey) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
}
prefix public func ! <RowDecoder>(aggregate: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func && <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func && <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func && <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func || <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func || <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func || <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func == <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func == <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func == <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func == <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: Swift.Bool) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func == <RowDecoder>(lhs: Swift.Bool, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func != <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func != <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func != <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func != <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: Swift.Bool) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func != <RowDecoder>(lhs: Swift.Bool, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func === <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func === <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func === <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func !== <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func !== <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func !== <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func <= <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func <= <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func <= <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func < <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func < <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func < <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func > <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func > <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func > <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func >= <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func >= <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func >= <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
prefix public func - <RowDecoder>(aggregate: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func + <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func + <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func + <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func - <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func - <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func - <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func * <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func * <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func * <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func / <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func / <RowDecoder>(lhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public func / <RowDecoder>(lhs: walletverse_ios_sdk.SQLExpressible, rhs: walletverse_ios_sdk.AssociationAggregate<RowDecoder>) -> walletverse_ios_sdk.AssociationAggregate<RowDecoder>
public protocol PluginType {
  func prepare(_ request: Foundation.URLRequest, target: walletverse_ios_sdk.TargetType) -> Foundation.URLRequest
  func willSend(_ request: walletverse_ios_sdk.RequestType, target: walletverse_ios_sdk.TargetType)
  func didReceive(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType)
  func process(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType) -> walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>
}
extension walletverse_ios_sdk.PluginType {
  public func prepare(_ request: Foundation.URLRequest, target: walletverse_ios_sdk.TargetType) -> Foundation.URLRequest
  public func willSend(_ request: walletverse_ios_sdk.RequestType, target: walletverse_ios_sdk.TargetType)
  public func didReceive(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType)
  public func process(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType) -> walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>
}
public protocol RequestType {
  var request: Foundation.URLRequest? { get }
  func authenticate(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence) -> Self
  func authenticate(usingCredential credential: Foundation.URLCredential) -> Self
}
@_hasMissingDesignatedInitializers public class DatabaseSnapshot : walletverse_ios_sdk.DatabaseReader {
  @objc deinit
}
extension walletverse_ios_sdk.DatabaseSnapshot {
  public func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  public func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  public func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  public func add(function: walletverse_ios_sdk.DatabaseFunction)
  public func remove(function: walletverse_ios_sdk.DatabaseFunction)
  public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
  public func add<Reducer>(observation: walletverse_ios_sdk.ValueObservation<Reducer>, onError: ((Swift.Error) -> Swift.Void)?, onChange: @escaping (Reducer.Value) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver where Reducer : walletverse_ios_sdk.ValueReducer
  public func remove(transactionObserver: walletverse_ios_sdk.TransactionObserver)
}
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func trackingCount<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.DistinctUntilChangedValueReducer<walletverse_ios_sdk.RawValueReducer<Swift.Int>>> where Request : walletverse_ios_sdk.FetchRequest
}
public struct BelongsToAssociation<Origin, Destination> : walletverse_ios_sdk.Association {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
  public var _impl: walletverse_ios_sdk.JoinAssociationImpl
  public init(_impl: walletverse_ios_sdk.JoinAssociationImpl)
  public typealias Impl = walletverse_ios_sdk.JoinAssociationImpl
}
extension walletverse_ios_sdk.BelongsToAssociation : walletverse_ios_sdk.TableRequest where Destination : walletverse_ios_sdk.TableRecord {
  public var databaseTableName: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.TableRecord {
  public static func belongsTo<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: walletverse_ios_sdk.ForeignKey? = nil) -> walletverse_ios_sdk.BelongsToAssociation<Self, Destination> where Destination : walletverse_ios_sdk.TableRecord
}
open class DateTransform : walletverse_ios_sdk.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
public func splittingRowAdapters(columnCounts: [Swift.Int]) -> [walletverse_ios_sdk.RowAdapter]
public struct LayoutedColumnMapping {
  public let layoutColumns: [(Swift.Int, Swift.String)]
  public init<S>(layoutColumns: S) where S : Swift.Sequence, S.Element == (Swift.Int, Swift.String)
}
extension walletverse_ios_sdk.LayoutedColumnMapping : walletverse_ios_sdk.LayoutedRowAdapter {
  public var mapping: walletverse_ios_sdk.LayoutedColumnMapping {
    get
  }
  public var scopes: [Swift.String : walletverse_ios_sdk.LayoutedRowAdapter] {
    get
  }
}
extension walletverse_ios_sdk.LayoutedColumnMapping : walletverse_ios_sdk.RowLayout {
  public func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol LayoutedRowAdapter {
  var mapping: walletverse_ios_sdk.LayoutedColumnMapping { get }
  var scopes: [Swift.String : walletverse_ios_sdk.LayoutedRowAdapter] { get }
}
public protocol RowLayout {
  var layoutColumns: [(Swift.Int, Swift.String)] { get }
  func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
extension walletverse_ios_sdk.SelectStatement : walletverse_ios_sdk.RowLayout {
  final public var layoutColumns: [(Swift.Int, Swift.String)] {
    get
  }
  final public func layoutIndex(ofColumn name: Swift.String) -> Swift.Int?
}
public protocol RowAdapter {
  func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
extension walletverse_ios_sdk.RowAdapter {
  public func addingScopes(_ scopes: [Swift.String : walletverse_ios_sdk.RowAdapter]) -> walletverse_ios_sdk.RowAdapter
}
public struct EmptyRowAdapter : walletverse_ios_sdk.RowAdapter {
  public init()
  public func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
public struct ColumnMapping : walletverse_ios_sdk.RowAdapter {
  public init(_ mapping: [Swift.String : Swift.String])
  public func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
public struct SuffixRowAdapter : walletverse_ios_sdk.RowAdapter {
  public init(fromIndex index: Swift.Int)
  public func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
public struct RangeRowAdapter : walletverse_ios_sdk.RowAdapter {
  public init(_ range: Swift.CountableRange<Swift.Int>)
  public init(_ range: Swift.CountableClosedRange<Swift.Int>)
  public func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
public struct ScopeAdapter : walletverse_ios_sdk.RowAdapter {
  public init(_ scopes: [Swift.String : walletverse_ios_sdk.RowAdapter])
  public init(base: walletverse_ios_sdk.RowAdapter, scopes: [Swift.String : walletverse_ios_sdk.RowAdapter])
  public func layoutedAdapter(from layout: walletverse_ios_sdk.RowLayout) throws -> walletverse_ios_sdk.LayoutedRowAdapter
}
extension Swift.String {
  public var quotedDatabaseIdentifier: Swift.String {
    get
  }
}
public func databaseQuestionMarks(count: Swift.Int) -> Swift.String
public protocol _OptionalProtocol {
  associatedtype _Wrapped
}
extension Swift.Optional : walletverse_ios_sdk._OptionalProtocol {
  public typealias _Wrapped = Wrapped
}
extension walletverse_ios_sdk.Row {
  @available(*, unavailable, message: "use subscript instead: row[index]")
  final public func value(atIndex index: Swift.Int) -> walletverse_ios_sdk.DatabaseValueConvertible?
  @available(*, unavailable, message: "use subscript instead: row[index]")
  final public func value<Value>(atIndex index: Swift.Int) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, message: "use subscript instead: row[index]")
  final public func value<Value>(atIndex index: Swift.Int) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value(named name: Swift.String) -> walletverse_ios_sdk.DatabaseValueConvertible?
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value<Value>(named name: Swift.String) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value<Value>(named name: Swift.String) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value(_ column: walletverse_ios_sdk.Column) -> walletverse_ios_sdk.DatabaseValueConvertible?
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value<Value>(_ column: walletverse_ios_sdk.Column) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, message: "use subscript instead: row[column]")
  final public func value<Value>(_ column: walletverse_ios_sdk.Column) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible
}
public enum PersistenceError : Swift.Error, Swift.CustomStringConvertible {
  case recordNotFound(walletverse_ios_sdk.MutablePersistableRecord)
}
extension walletverse_ios_sdk.PersistenceError {
  public var description: Swift.String {
    get
  }
}
public struct PersistenceContainer {
  public subscript(column: Swift.String) -> walletverse_ios_sdk.DatabaseValueConvertible? {
    get
    set
  }
  public subscript(column: walletverse_ios_sdk.ColumnExpression) -> walletverse_ios_sdk.DatabaseValueConvertible? {
    get
    set
  }
}
public struct PersistenceConflictPolicy {
  public let conflictResolutionForInsert: walletverse_ios_sdk.GDatabase.ConflictResolution
  public let conflictResolutionForUpdate: walletverse_ios_sdk.GDatabase.ConflictResolution
  public init(insert: walletverse_ios_sdk.GDatabase.ConflictResolution = .abort, update: walletverse_ios_sdk.GDatabase.ConflictResolution = .abort)
}
public protocol MutablePersistableRecord : walletverse_ios_sdk.TableRecord {
  static var persistenceConflictPolicy: walletverse_ios_sdk.PersistenceConflictPolicy { get }
  func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
  mutating func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  mutating func insert(_ db: walletverse_ios_sdk.GDatabase) throws
  func update(_ db: walletverse_ios_sdk.GDatabase, columns: Swift.Set<Swift.String>) throws
  mutating func save(_ db: walletverse_ios_sdk.GDatabase) throws
  @discardableResult
  func delete(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  func exists(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  static var databaseDateEncodingStrategy: walletverse_ios_sdk.DatabaseDateEncodingStrategy { get }
  static var databaseUUIDEncodingStrategy: walletverse_ios_sdk.DatabaseUUIDEncodingStrategy { get }
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  public static var databaseEncodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONEncoder(for column: Swift.String) -> Foundation.JSONEncoder
  public static var databaseDateEncodingStrategy: walletverse_ios_sdk.DatabaseDateEncodingStrategy {
    get
  }
  public static var databaseUUIDEncodingStrategy: walletverse_ios_sdk.DatabaseUUIDEncodingStrategy {
    get
  }
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  public var databaseDictionary: [Swift.String : walletverse_ios_sdk.DatabaseValue] {
    get
  }
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  public static var persistenceConflictPolicy: walletverse_ios_sdk.PersistenceConflictPolicy {
    get
  }
  public mutating func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  public mutating func insert(_ db: walletverse_ios_sdk.GDatabase) throws
  public func update(_ db: walletverse_ios_sdk.GDatabase, columns: Swift.Set<Swift.String>) throws
  public func update<Sequence>(_ db: walletverse_ios_sdk.GDatabase, columns: Sequence) throws where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.ColumnExpression
  public func update<Sequence>(_ db: walletverse_ios_sdk.GDatabase, columns: Sequence) throws where Sequence : Swift.Sequence, Sequence.Element == Swift.String
  public func update(_ db: walletverse_ios_sdk.GDatabase) throws
  @discardableResult
  public func updateChanges(_ db: walletverse_ios_sdk.GDatabase, from record: walletverse_ios_sdk.MutablePersistableRecord) throws -> Swift.Bool
  @discardableResult
  public mutating func updateChanges(_ db: walletverse_ios_sdk.GDatabase, with change: (inout Self) throws -> Swift.Void) throws -> Swift.Bool
  public mutating func save(_ db: walletverse_ios_sdk.GDatabase) throws
  @discardableResult
  public func delete(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  public func exists(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  public func databaseEquals(_ record: Self) -> Swift.Bool
  public func databaseChanges(from record: walletverse_ios_sdk.MutablePersistableRecord) -> [Swift.String : walletverse_ios_sdk.DatabaseValue]
  public mutating func performInsert(_ db: walletverse_ios_sdk.GDatabase) throws
  public func performUpdate(_ db: walletverse_ios_sdk.GDatabase, columns: Swift.Set<Swift.String>) throws
  public mutating func performSave(_ db: walletverse_ios_sdk.GDatabase) throws
  public func performDelete(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
  public func performExists(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Bool
}
extension walletverse_ios_sdk.MutablePersistableRecord where Self : AnyObject {
  @discardableResult
  public func updateChanges(_ db: walletverse_ios_sdk.GDatabase, with change: (Self) throws -> Swift.Void) throws -> Swift.Bool
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  @discardableResult
  public static func deleteAll(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  @discardableResult
  public static func deleteAll<Sequence>(_ db: walletverse_ios_sdk.GDatabase, keys: Sequence) throws -> Swift.Int where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  @discardableResult
  public static func deleteOne<PrimaryKeyType>(_ db: walletverse_ios_sdk.GDatabase, key: PrimaryKeyType?) throws -> Swift.Bool where PrimaryKeyType : walletverse_ios_sdk.DatabaseValueConvertible
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  @discardableResult
  public static func deleteAll(_ db: walletverse_ios_sdk.GDatabase, keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) throws -> Swift.Int
  @discardableResult
  public static func deleteOne(_ db: walletverse_ios_sdk.GDatabase, key: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]) throws -> Swift.Bool
}
public protocol PersistableRecord : walletverse_ios_sdk.MutablePersistableRecord {
  func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  func insert(_ db: walletverse_ios_sdk.GDatabase) throws
  func save(_ db: walletverse_ios_sdk.GDatabase) throws
}
extension walletverse_ios_sdk.PersistableRecord {
  public func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  public func insert(_ db: walletverse_ios_sdk.GDatabase) throws
  public func save(_ db: walletverse_ios_sdk.GDatabase) throws
  public func performInsert(_ db: walletverse_ios_sdk.GDatabase) throws
  public func performSave(_ db: walletverse_ios_sdk.GDatabase) throws
}
public enum DatabaseDateEncodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case secondsSince1970
  case millisecondsSince1970
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((Foundation.Date) -> walletverse_ios_sdk.DatabaseValueConvertible?)
}
public enum DatabaseUUIDEncodingStrategy {
  case deferredToUUID
  case string
  public static func == (a: walletverse_ios_sdk.DatabaseUUIDEncodingStrategy, b: walletverse_ios_sdk.DatabaseUUIDEncodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class SessionDelegate : ObjectiveC.NSObject {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var sessionDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var sessionDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var sessionDidFinishEventsForBackgroundURLSession: ((Foundation.URLSession) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Foundation.URLRequest?)?
  open var taskWillPerformHTTPRedirectionWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest, @escaping (Foundation.URLRequest?) -> Swift.Void) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?))?
  open var taskDidReceiveChallengeWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge, @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Foundation.InputStream?)?
  open var taskNeedNewBodyStreamWithCompletion: ((Foundation.URLSession, Foundation.URLSessionTask, @escaping (Foundation.InputStream?) -> Swift.Void) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var dataTaskDidReceiveResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse) -> Foundation.URLSession.ResponseDisposition)?
  open var dataTaskDidReceiveResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse, @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void) -> Swift.Void)?
  open var dataTaskDidBecomeDownloadTask: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLSessionDownloadTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)?
  open var dataTaskWillCacheResponseWithCompletion: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse, @escaping (Foundation.CachedURLResponse?) -> Swift.Void) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskReadClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskWriteClosed: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskBetterRouteDiscovered: ((Foundation.URLSession, Foundation.URLSessionStreamTask) -> Swift.Void)? {
    get
    set
  }
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  open var streamTaskDidBecomeInputAndOutputStreams: ((Foundation.URLSession, Foundation.URLSessionStreamTask, Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? {
    get
    set
  }
  open subscript(task: Foundation.URLSessionTask) -> walletverse_ios_sdk.ARequest? {
    get
    set
  }
  @objc override dynamic public init()
  @objc override dynamic open func responds(to selector: ObjectiveC.Selector) -> Swift.Bool
  @objc deinit
}
extension walletverse_ios_sdk.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
}
extension walletverse_ios_sdk.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
  @objc(URLSession:task:didFinishCollectingMetrics:) dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
}
extension walletverse_ios_sdk.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didBecome downloadTask: Foundation.URLSessionDownloadTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension walletverse_ios_sdk.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
}
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
extension walletverse_ios_sdk.SessionDelegate : Foundation.URLSessionStreamDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, readClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, writeClosedFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, betterRouteDiscoveredFor streamTask: Foundation.URLSessionStreamTask)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, streamTask: Foundation.URLSessionStreamTask, didBecome inputStream: Foundation.InputStream, outputStream: Foundation.OutputStream)
}
public struct GConfiguration {
  public var foreignKeysEnabled: Swift.Bool
  public var readonly: Swift.Bool
  public var label: Swift.String?
  public var trace: walletverse_ios_sdk.TraceFunction?
  public var defaultTransactionKind: walletverse_ios_sdk.GDatabase.TransactionKind
  public var allowsUnsafeTransactions: Swift.Bool
  public var busyMode: walletverse_ios_sdk.GDatabase.BusyMode
  public var maximumReaderCount: Swift.Int
  public var qos: Dispatch.DispatchQoS
  public var targetQueue: Dispatch.DispatchQueue?
  public init()
}
public typealias TraceFunction = (Swift.String) -> Swift.Void
extension walletverse_ios_sdk.SQLSpecificExpressible {
  public var asc: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
  public var desc: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
}
extension walletverse_ios_sdk.SQLSpecificExpressible {
  public func aliased(_ name: Swift.String) -> walletverse_ios_sdk.SQLSelectable
  public func aliased(_ key: Swift.CodingKey) -> walletverse_ios_sdk.SQLSelectable
}
extension walletverse_ios_sdk.SQLSpecificExpressible {
  public func collating(_ collation: walletverse_ios_sdk.GDatabase.CollationName) -> walletverse_ios_sdk.SQLCollatedExpression
  public func collating(_ collation: walletverse_ios_sdk.DatabaseCollation) -> walletverse_ios_sdk.SQLCollatedExpression
}
extension walletverse_ios_sdk.HandyJSON {
  public func toJSON() -> [Swift.String : Any]?
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Collection where Self.Element : walletverse_ios_sdk.HandyJSON {
  public func toJSON() -> [[Swift.String : Any]?]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
@available(*, unavailable, renamed: "Database.BusyMode")
public typealias BusyMode = walletverse_ios_sdk.GDatabase.BusyMode
@available(*, unavailable, renamed: "Database.CheckpointMode")
public typealias CheckpointMode = walletverse_ios_sdk.GDatabase.CheckpointMode
@available(*, unavailable, renamed: "Database.TransactionKind")
public typealias TransactionKind = walletverse_ios_sdk.GDatabase.TransactionKind
@available(*, unavailable, renamed: "Database.TransactionCompletion")
public typealias TransactionCompletion = walletverse_ios_sdk.GDatabase.TransactionCompletion
@available(*, unavailable, renamed: "Database.BusyCallback")
public typealias BusyCallback = walletverse_ios_sdk.GDatabase.BusyCallback
extension walletverse_ios_sdk.DatabasePool {
  @available(*, unavailable, renamed: "setupMemoryManagement(in:)")
  final public func setupMemoryManagement(application: UIKit.UIApplication)
}
extension walletverse_ios_sdk.DatabaseQueue {
  @available(*, unavailable, renamed: "setupMemoryManagement(in:)")
  final public func setupMemoryManagement(application: UIKit.UIApplication)
}
extension walletverse_ios_sdk.GDatabase {
  @available(*, unavailable, renamed: "add(function:)")
  final public func addFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
  @available(*, unavailable, renamed: "remove(function:)")
  final public func removeFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
}
extension walletverse_ios_sdk.DatabasePool {
  @available(*, unavailable, renamed: "add(function:)")
  final public func addFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
  @available(*, unavailable, renamed: "remove(function:)")
  final public func removeFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
}
extension walletverse_ios_sdk.DatabaseQueue {
  @available(*, unavailable, renamed: "add(function:)")
  final public func addFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
  @available(*, unavailable, renamed: "remove(function:)")
  final public func removeFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
}
extension walletverse_ios_sdk.DatabaseReader {
  @available(*, unavailable, renamed: "add(function:)")
  public func addFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
  @available(*, unavailable, renamed: "remove(function:)")
  public func removeFunction(_ function: walletverse_ios_sdk.DatabaseFunction)
}
extension walletverse_ios_sdk.DatabaseFunction {
  @available(*, unavailable, renamed: "capitalize")
  public static let capitalizedString: walletverse_ios_sdk.DatabaseFunction
  @available(*, unavailable, renamed: "lowercase")
  public static let lowercaseString: walletverse_ios_sdk.DatabaseFunction
  @available(*, unavailable, renamed: "uppercase")
  public static let uppercaseString: walletverse_ios_sdk.DatabaseFunction
}
@available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
extension walletverse_ios_sdk.DatabaseFunction {
  @available(*, unavailable, renamed: "localizedCapitalize")
  public static let localizedCapitalizedString: walletverse_ios_sdk.DatabaseFunction
  @available(*, unavailable, renamed: "localizedLowercase")
  public static let localizedLowercaseString: walletverse_ios_sdk.DatabaseFunction
  @available(*, unavailable, renamed: "localizedUppercase")
  public static let localizedUppercaseString: walletverse_ios_sdk.DatabaseFunction
}
extension walletverse_ios_sdk.GDatabase {
  @available(*, unavailable, renamed: "add(collation:)")
  final public func addCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
  @available(*, unavailable, renamed: "remove(collation:)")
  final public func removeCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.DatabasePool {
  @available(*, unavailable, renamed: "add(collation:)")
  final public func addCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
  @available(*, unavailable, renamed: "remove(collation:)")
  final public func removeCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.DatabaseQueue {
  @available(*, unavailable, renamed: "add(collation:)")
  final public func addCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
  @available(*, unavailable, renamed: "remove(collation:)")
  final public func removeCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.DatabaseReader {
  @available(*, unavailable, renamed: "add(collation:)")
  public func addCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
  @available(*, unavailable, renamed: "remove(collation:)")
  public func removeCollation(_ collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.Statement {
  @available(*, unavailable, renamed: "validate(arguments:)")
  public func validateArguments(_ arguments: walletverse_ios_sdk.StatementArguments) throws
}
extension walletverse_ios_sdk.GDatabase {
  @available(*, unavailable, message: "Use add(transactionObserver:) instead. Database events filtering is now performed by transaction observers themselves.")
  final public func addTransactionObserver(_ transactionObserver: walletverse_ios_sdk.TransactionObserver, forDatabaseEvents filter: ((walletverse_ios_sdk.DatabaseEventKind) -> Swift.Bool)? = nil)
  @available(*, unavailable, renamed: "remove(transactionObserver:)")
  final public func removeTransactionObserver(_ transactionObserver: walletverse_ios_sdk.TransactionObserver)
}
extension walletverse_ios_sdk.DatabaseWriter {
  @available(*, unavailable, message: "Use add(transactionObserver:) instead. Database events filtering is now performed by transaction observers themselves.")
  public func addTransactionObserver(_ transactionObserver: walletverse_ios_sdk.TransactionObserver, forDatabaseEvents filter: ((walletverse_ios_sdk.DatabaseEventKind) -> Swift.Bool)? = nil)
  @available(*, unavailable, renamed: "remove(transactionObserver:)")
  public func removeTransactionObserver(_ transactionObserver: walletverse_ios_sdk.TransactionObserver)
}
@available(*, unavailable, renamed: "TransactionObserver")
public typealias TransactionObserverType = walletverse_ios_sdk.TransactionObserver
@available(*, unavailable, renamed: "Column")
public typealias SQLColumn = walletverse_ios_sdk.Column
extension walletverse_ios_sdk.SQLSpecificExpressible {
  @available(*, unavailable, renamed: "capitalized")
  public var capitalizedString: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(*, unavailable, renamed: "lowercased")
  public var lowercaseString: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(*, unavailable, renamed: "uppercased")
  public var uppercaseString: walletverse_ios_sdk.SQLExpression {
    get
  }
}
@available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
extension walletverse_ios_sdk.SQLSpecificExpressible {
  @available(*, unavailable, renamed: "localizedCapitalized")
  public var localizedCapitalizedString: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(*, unavailable, renamed: "localizedLowercased")
  public var localizedLowercaseString: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(*, unavailable, renamed: "localizedUppercased")
  public var localizedUppercaseString: walletverse_ios_sdk.SQLExpression {
    get
  }
}
public struct FTS3 : walletverse_ios_sdk.VirtualTableModule {
  public init()
  public let moduleName: Swift.String
  public func makeTableDefinition() -> walletverse_ios_sdk.FTS3TableDefinition
  public func moduleArguments(for definition: walletverse_ios_sdk.FTS3TableDefinition, in db: walletverse_ios_sdk.GDatabase) -> [Swift.String]
  public func database(_ db: walletverse_ios_sdk.GDatabase, didCreate tableName: Swift.String, using definition: walletverse_ios_sdk.FTS3TableDefinition)
  public typealias TableDefinition = walletverse_ios_sdk.FTS3TableDefinition
}
@_hasMissingDesignatedInitializers final public class FTS3TableDefinition {
  final public var tokenizer: walletverse_ios_sdk.FTS3TokenizerDescriptor?
  final public func column(_ name: Swift.String)
  @objc deinit
}
public protocol SQLSelectable {
  func resultColumnSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  func countedSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  func count(distinct: Swift.Bool) -> walletverse_ios_sdk.SQLCount?
  func columnCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
  func qualifiedSelectable(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLSelectable
}
public enum SQLCount {
  case all
  case distinct(walletverse_ios_sdk.SQLExpression)
}
public protocol ResultProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  init(value: Self.Value)
  init(error: Self.Error)
  var result: walletverse_ios_sdk.RResult<Self.Value, Self.Error> { get }
}
extension walletverse_ios_sdk.RResult {
  public var value: Value? {
    get
  }
  public var error: Error? {
    get
  }
  public func map<U>(_ transform: (Value) -> U) -> walletverse_ios_sdk.RResult<U, Error>
  public func flatMap<U>(_ transform: (Value) -> walletverse_ios_sdk.RResult<U, Error>) -> walletverse_ios_sdk.RResult<U, Error>
  public func fanout<U>(_ other: @autoclosure () -> walletverse_ios_sdk.RResult<U, Error>) -> walletverse_ios_sdk.RResult<(Value, U), Error>
  public func mapError<Error2>(_ transform: (Error) -> Error2) -> walletverse_ios_sdk.RResult<Value, Error2> where Error2 : Swift.Error
  public func flatMapError<Error2>(_ transform: (Error) -> walletverse_ios_sdk.RResult<Value, Error2>) -> walletverse_ios_sdk.RResult<Value, Error2> where Error2 : Swift.Error
  public func bimap<U, Error2>(success: (Value) -> U, failure: (Error) -> Error2) -> walletverse_ios_sdk.RResult<U, Error2> where Error2 : Swift.Error
}
extension walletverse_ios_sdk.RResult {
  public func recover(_ value: @autoclosure () -> Value) -> Value
  public func recover(with result: @autoclosure () -> walletverse_ios_sdk.RResult<Value, Error>) -> walletverse_ios_sdk.RResult<Value, Error>
}
public protocol ErrorConvertible : Swift.Error {
  static func error(from error: Swift.Error) -> Self
}
extension walletverse_ios_sdk.RResult where Error : walletverse_ios_sdk.ErrorConvertible {
  public func tryMap<U>(_ transform: (Value) throws -> U) -> walletverse_ios_sdk.RResult<U, Error>
}
extension walletverse_ios_sdk.RResult where Value : Swift.Equatable, Error : Swift.Equatable {
  public static func == (left: walletverse_ios_sdk.RResult<Value, Error>, right: walletverse_ios_sdk.RResult<Value, Error>) -> Swift.Bool
}
extension walletverse_ios_sdk.RResult : Swift.Equatable where Value : Swift.Equatable, Error : Swift.Equatable {
}
extension walletverse_ios_sdk.RResult {
  public static func ?? (left: walletverse_ios_sdk.RResult<Value, Error>, right: @autoclosure () -> Value) -> Value
  public static func ?? (left: walletverse_ios_sdk.RResult<Value, Error>, right: @autoclosure () -> walletverse_ios_sdk.RResult<Value, Error>) -> walletverse_ios_sdk.RResult<Value, Error>
}
@available(*, unavailable, renamed: "ErrorConvertible")
public protocol ErrorProtocolConvertible : walletverse_ios_sdk.ErrorConvertible {
}
extension walletverse_ios_sdk.FetchableRecord where Self : walletverse_ios_sdk.TableRecord {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.RecordCursor<Self>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase) throws -> Self?
}
extension walletverse_ios_sdk.FetchableRecord where Self : walletverse_ios_sdk.TableRecord {
  public static func fetchCursor<Sequence>(_ db: walletverse_ios_sdk.GDatabase, keys: Sequence) throws -> walletverse_ios_sdk.RecordCursor<Self> where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  public static func fetchAll<Sequence>(_ db: walletverse_ios_sdk.GDatabase, keys: Sequence) throws -> [Self] where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  public static func fetchOne<PrimaryKeyType>(_ db: walletverse_ios_sdk.GDatabase, key: PrimaryKeyType?) throws -> Self? where PrimaryKeyType : walletverse_ios_sdk.DatabaseValueConvertible
}
extension walletverse_ios_sdk.FetchableRecord where Self : walletverse_ios_sdk.TableRecord {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) throws -> walletverse_ios_sdk.RecordCursor<Self>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) throws -> [Self]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase, key: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]?) throws -> Self?
}
final public class DatabaseQueue : walletverse_ios_sdk.DatabaseWriter {
  final public var configuration: walletverse_ios_sdk.GConfiguration {
    get
  }
  final public var path: Swift.String {
    get
  }
  public init(path: Swift.String, configuration: walletverse_ios_sdk.GConfiguration = GConfiguration()) throws
  public init(configuration: walletverse_ios_sdk.GConfiguration = GConfiguration())
  @objc deinit
}
extension walletverse_ios_sdk.DatabaseQueue {
  final public func releaseMemory()
  final public func setupMemoryManagement(in application: UIKit.UIApplication)
}
extension walletverse_ios_sdk.DatabaseQueue {
  final public func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  @available(*, deprecated, message: "Use concurrentRead instead")
  final public func readFromCurrentState(_ block: @escaping (walletverse_ios_sdk.GDatabase) -> Swift.Void)
  final public func concurrentRead<T>(_ block: @escaping (walletverse_ios_sdk.GDatabase) throws -> T) -> walletverse_ios_sdk.Future<T>
  final public func write<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func inTransaction(_ kind: walletverse_ios_sdk.GDatabase.TransactionKind? = nil, _ block: (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.GDatabase.TransactionCompletion) throws
  final public func writeWithoutTransaction<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func inDatabase<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func unsafeReentrantWrite<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func add(function: walletverse_ios_sdk.DatabaseFunction)
  final public func remove(function: walletverse_ios_sdk.DatabaseFunction)
  final public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CoinModel : walletverse_ios_sdk.Record, Foundation.NSCoding {
  public var id: Swift.Int64?
  public var chainId: Swift.String?
  public var symbol: Swift.String?
  public var name: Swift.String?
  public var chainName: Swift.String?
  public var contract: Swift.String?
  public var contractAddress: Swift.String?
  public var iconUrl: Swift.String?
  public var scanUrl: Swift.String?
  public var rpcUrl: Swift.String?
  public var decimals: Swift.String?
  public var type: Swift.String?
  public var vm: Swift.String?
  public var extra: Swift.String?
  override public func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
  override public func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  override public class var databaseTableName: Swift.String {
    get
  }
  @objc required public init(coder decoder: Foundation.NSCoder)
  @objc public func encode(with coder: Foundation.NSCoder)
  public func fromWalletCoin(walletCoin: walletverse_ios_sdk.WalletCoinModel)
  @objc deinit
}
open class AMultipartFormData {
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  public var boundary: Swift.String
  public init()
  public func append(_ data: Foundation.Data, withName name: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, mimeType: Swift.String)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: walletverse_ios_sdk.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
open class SessionManager {
  public enum MultipartFormDataEncodingResult {
    case success(request: walletverse_ios_sdk.UploadRequest, streamingFromDisk: Swift.Bool, streamFileURL: Foundation.URL?)
    case failure(Swift.Error)
  }
  public static let `default`: walletverse_ios_sdk.SessionManager
  public static let defaultHTTPHeaders: walletverse_ios_sdk.HTTPHeaders
  public static let multipartFormDataEncodingMemoryThreshold: Swift.UInt64
  final public let session: Foundation.URLSession
  final public let delegate: walletverse_ios_sdk.SessionDelegate
  open var startRequestsImmediately: Swift.Bool
  open var adapter: walletverse_ios_sdk.RequestAdapter?
  open var retrier: walletverse_ios_sdk.RequestRetrier? {
    get
    set
  }
  open var backgroundCompletionHandler: (() -> Swift.Void)?
  public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.default, delegate: walletverse_ios_sdk.SessionDelegate = SessionDelegate(), serverTrustPolicyManager: walletverse_ios_sdk.ServerTrustPolicyManager? = nil)
  public init?(session: Foundation.URLSession, delegate: walletverse_ios_sdk.SessionDelegate, serverTrustPolicyManager: walletverse_ios_sdk.ServerTrustPolicyManager? = nil)
  @objc deinit
  @discardableResult
  open func request(_ url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .get, parameters: walletverse_ios_sdk.Parameters? = nil, encoding: walletverse_ios_sdk.ParameterEncoding = URLEncoding.default, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.DataRequest
  @discardableResult
  open func request(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.DataRequest
  @discardableResult
  open func download(_ url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .get, parameters: walletverse_ios_sdk.Parameters? = nil, encoding: walletverse_ios_sdk.ParameterEncoding = URLEncoding.default, headers: walletverse_ios_sdk.HTTPHeaders? = nil, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
  @discardableResult
  open func download(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
  @discardableResult
  open func download(resumingWith resumeData: Foundation.Data, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
  @discardableResult
  open func upload(_ fileURL: Foundation.URL, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
  @discardableResult
  open func upload(_ data: Foundation.Data, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
  @discardableResult
  open func upload(_ stream: Foundation.InputStream, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
  open func upload(multipartFormData: @escaping (walletverse_ios_sdk.AMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((walletverse_ios_sdk.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  open func upload(multipartFormData: @escaping (walletverse_ios_sdk.AMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, with urlRequest: walletverse_ios_sdk.URLRequestConvertible, queue: Dispatch.DispatchQueue? = nil, encodingCompletion: ((walletverse_ios_sdk.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(withHostName hostName: Swift.String, port: Swift.Int) -> walletverse_ios_sdk.StreamRequest
  @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
  @discardableResult
  open func stream(with netService: Foundation.NetService) -> walletverse_ios_sdk.StreamRequest
}
public protocol StatementColumnConvertible {
  init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
}
@_hasMissingDesignatedInitializers final public class FastDatabaseValueCursor<Value> : walletverse_ios_sdk.Cursor where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
  @objc deinit
  final public func next() throws -> Value?
  public typealias Element = Value
}
@available(*, deprecated, renamed: "FastDatabaseValueCursor")
public typealias ColumnCursor<Value> = walletverse_ios_sdk.FastDatabaseValueCursor<Value> where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible
@_hasMissingDesignatedInitializers final public class FastNullableDatabaseValueCursor<Value> : walletverse_ios_sdk.Cursor where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
  @objc deinit
  final public func next() throws -> Value??
  public typealias Element = Value?
}
@available(*, deprecated, renamed: "FastNullableDatabaseValueCursor")
public typealias NullableColumnCursor<Value> = walletverse_ios_sdk.FastNullableDatabaseValueCursor<Value> where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.FastDatabaseValueCursor<Self>
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.FastDatabaseValueCursor<Self>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.FastDatabaseValueCursor<Self> where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [Self] where R : walletverse_ios_sdk.FetchRequest
  public static func fetchOne<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> Self? where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible, Self.RowDecoder : walletverse_ios_sdk.StatementColumnConvertible {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.FastDatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: walletverse_ios_sdk.GDatabase) throws -> Self.RowDecoder?
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible, Wrapped : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.FastNullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible, Wrapped : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.FastNullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible, Wrapped : walletverse_ios_sdk.StatementColumnConvertible {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.FastNullableDatabaseValueCursor<Wrapped> where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [Wrapped?] where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk._OptionalProtocol, Self.RowDecoder._Wrapped : walletverse_ios_sdk.DatabaseValueConvertible, Self.RowDecoder._Wrapped : walletverse_ios_sdk.StatementColumnConvertible {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.FastNullableDatabaseValueCursor<Self.RowDecoder._Wrapped>
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self.RowDecoder._Wrapped?]
}
public enum ValidationType {
  case none
  case successCodes
  case successAndRedirectCodes
  case customCodes([Swift.Int])
}
extension walletverse_ios_sdk.ValidationType : Swift.Equatable {
  public static func == (lhs: walletverse_ios_sdk.ValidationType, rhs: walletverse_ios_sdk.ValidationType) -> Swift.Bool
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : walletverse_ios_sdk.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : walletverse_ios_sdk.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : walletverse_ios_sdk.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension walletverse_ios_sdk.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : walletverse_ios_sdk.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod, headers: walletverse_ios_sdk.HTTPHeaders? = nil) throws
}
@discardableResult
public func request(_ url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .get, parameters: walletverse_ios_sdk.Parameters? = nil, encoding: walletverse_ios_sdk.ParameterEncoding = URLEncoding.default, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.DataRequest
@discardableResult
public func request(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.DataRequest
@discardableResult
public func download(_ url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .get, parameters: walletverse_ios_sdk.Parameters? = nil, encoding: walletverse_ios_sdk.ParameterEncoding = URLEncoding.default, headers: walletverse_ios_sdk.HTTPHeaders? = nil, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
@discardableResult
public func download(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
@discardableResult
public func download(resumingWith resumeData: Foundation.Data, to destination: walletverse_ios_sdk.DownloadRequest.DownloadFileDestination? = nil) -> walletverse_ios_sdk.DownloadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
@discardableResult
public func upload(_ fileURL: Foundation.URL, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
@discardableResult
public func upload(_ data: Foundation.Data, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil) -> walletverse_ios_sdk.UploadRequest
@discardableResult
public func upload(_ stream: Foundation.InputStream, with urlRequest: walletverse_ios_sdk.URLRequestConvertible) -> walletverse_ios_sdk.UploadRequest
public func upload(multipartFormData: @escaping (walletverse_ios_sdk.AMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, to url: walletverse_ios_sdk.URLConvertible, method: walletverse_ios_sdk.HTTPMethod = .post, headers: walletverse_ios_sdk.HTTPHeaders? = nil, encodingCompletion: ((walletverse_ios_sdk.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
public func upload(multipartFormData: @escaping (walletverse_ios_sdk.AMultipartFormData) -> Swift.Void, usingThreshold encodingMemoryThreshold: Swift.UInt64 = SessionManager.multipartFormDataEncodingMemoryThreshold, with urlRequest: walletverse_ios_sdk.URLRequestConvertible, encodingCompletion: ((walletverse_ios_sdk.SessionManager.MultipartFormDataEncodingResult) -> Swift.Void)?)
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
@discardableResult
public func stream(withHostName hostName: Swift.String, port: Swift.Int) -> walletverse_ios_sdk.StreamRequest
@available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
@discardableResult
public func stream(with netService: Foundation.NetService) -> walletverse_ios_sdk.StreamRequest
public struct AllColumns {
  public init()
}
extension walletverse_ios_sdk.AllColumns : walletverse_ios_sdk.SQLSelectable {
  public func resultColumnSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func countedSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func count(distinct: Swift.Bool) -> walletverse_ios_sdk.SQLCount?
  public func qualifiedSelectable(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLSelectable
  public func columnCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.QueryInterfaceRequest where T : walletverse_ios_sdk.TableRecord {
  public func including<A>(optional association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<T> where T == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public func including<A>(required association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<T> where T == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public func joining<A>(optional association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<T> where T == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public func joining<A>(required association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<T> where T == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public func annotated(with aggregates: walletverse_ios_sdk.AssociationAggregate<walletverse_ios_sdk.QueryInterfaceRequest<T>.RowDecoder>...) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func annotated(with aggregates: [walletverse_ios_sdk.AssociationAggregate<walletverse_ios_sdk.QueryInterfaceRequest<T>.RowDecoder>]) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func having(_ predicate: walletverse_ios_sdk.AssociationAggregate<walletverse_ios_sdk.QueryInterfaceRequest<T>.RowDecoder>) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  public func request<A>(for association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<A.RowDecoder> where Self == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
}
extension walletverse_ios_sdk.TableRecord {
  public static func including<A>(optional association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public static func including<A>(required association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public static func joining<A>(optional association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public static func joining<A>(required association: A) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where Self == A.OriginRowDecoder, A : walletverse_ios_sdk.Association
  public static func annotated(with aggregates: walletverse_ios_sdk.AssociationAggregate<Self>...) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func annotated(with aggregates: [walletverse_ios_sdk.AssociationAggregate<Self>]) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func having(_ predicate: walletverse_ios_sdk.AssociationAggregate<Self>) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
}
public protocol TargetType {
  var baseURL: Foundation.URL { get }
  var path: Swift.String { get }
  var method: walletverse_ios_sdk.Method { get }
  var sampleData: Foundation.Data { get }
  var task: walletverse_ios_sdk.Task { get }
  var validationType: walletverse_ios_sdk.ValidationType { get }
  var headers: [Swift.String : Swift.String]? { get }
}
extension walletverse_ios_sdk.TargetType {
  public var validationType: walletverse_ios_sdk.ValidationType {
    get
  }
}
public protocol DatabaseReader : AnyObject {
  func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  func add(function: walletverse_ios_sdk.DatabaseFunction)
  func remove(function: walletverse_ios_sdk.DatabaseFunction)
  func add(collation: walletverse_ios_sdk.DatabaseCollation)
  func remove(collation: walletverse_ios_sdk.DatabaseCollation)
  func add<Reducer>(observation: walletverse_ios_sdk.ValueObservation<Reducer>, onError: ((Swift.Error) -> Swift.Void)?, onChange: @escaping (Reducer.Value) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver where Reducer : walletverse_ios_sdk.ValueReducer
  func remove(transactionObserver: walletverse_ios_sdk.TransactionObserver)
}
extension walletverse_ios_sdk.DatabaseReader {
  public func backup(to writer: walletverse_ios_sdk.DatabaseWriter) throws
}
final public class AnyDatabaseReader : walletverse_ios_sdk.DatabaseReader {
  public init(_ base: walletverse_ios_sdk.DatabaseReader)
  final public func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func add(function: walletverse_ios_sdk.DatabaseFunction)
  final public func remove(function: walletverse_ios_sdk.DatabaseFunction)
  final public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func add<Reducer>(observation: walletverse_ios_sdk.ValueObservation<Reducer>, onError: ((Swift.Error) -> Swift.Void)?, onChange: @escaping (Reducer.Value) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver where Reducer : walletverse_ios_sdk.ValueReducer
  final public func remove(transactionObserver: walletverse_ios_sdk.TransactionObserver)
  @objc deinit
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest) throws -> Foundation.URLRequest
}
public typealias RequestRetryCompletion = (_ shouldRetry: Swift.Bool, _ timeDelay: Foundation.TimeInterval) -> Swift.Void
public protocol RequestRetrier {
  func should(_ manager: walletverse_ios_sdk.SessionManager, retry request: walletverse_ios_sdk.ARequest, with error: Swift.Error, completion: @escaping walletverse_ios_sdk.RequestRetryCompletion)
}
public typealias HTTPHeaders = [Swift.String : Swift.String]
@_hasMissingDesignatedInitializers open class ARequest {
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  open var delegate: walletverse_ios_sdk.TaskDelegate {
    get
  }
  open var task: Foundation.URLSessionTask? {
    get
  }
  final public let session: Foundation.URLSession
  open var request: Foundation.URLRequest? {
    get
  }
  open var response: Foundation.HTTPURLResponse? {
    get
  }
  open var retryCount: Swift.UInt {
    get
  }
  @discardableResult
  open func authenticate(user: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  open func authenticate(usingCredential credential: Foundation.URLCredential) -> Self
  open class func authorizationHeader(user: Swift.String, password: Swift.String) -> (key: Swift.String, value: Swift.String)?
  open func resume()
  open func suspend()
  open func cancel()
  @objc deinit
}
extension walletverse_ios_sdk.ARequest : Swift.CustomStringConvertible {
  open var description: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.ARequest : Swift.CustomDebugStringConvertible {
  open var debugDescription: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DataRequest : walletverse_ios_sdk.ARequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  @discardableResult
  open func stream(closure: ((Foundation.Data) -> Swift.Void)? = nil) -> Self
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping walletverse_ios_sdk.DataRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class DownloadRequest : walletverse_ios_sdk.ARequest {
  public struct DownloadOptions : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public static let createIntermediateDirectories: walletverse_ios_sdk.DownloadRequest.DownloadOptions
    public static let removePreviousFile: walletverse_ios_sdk.DownloadRequest.DownloadOptions
    public init(rawValue: Swift.UInt)
    public typealias ArrayLiteralElement = walletverse_ios_sdk.DownloadRequest.DownloadOptions
    public typealias Element = walletverse_ios_sdk.DownloadRequest.DownloadOptions
    public typealias RawValue = Swift.UInt
  }
  public typealias DownloadFileDestination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: walletverse_ios_sdk.DownloadRequest.DownloadOptions)
  override open var request: Foundation.URLRequest? {
    get
  }
  open var resumeData: Foundation.Data? {
    get
  }
  open var progress: Foundation.Progress {
    get
  }
  override open func cancel()
  open func cancel(createResumeData: Swift.Bool)
  @discardableResult
  open func downloadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping walletverse_ios_sdk.DownloadRequest.ProgressHandler) -> Self
  open class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask) -> walletverse_ios_sdk.DownloadRequest.DownloadFileDestination
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class UploadRequest : walletverse_ios_sdk.DataRequest {
  override open var request: Foundation.URLRequest? {
    get
  }
  open var uploadProgress: Foundation.Progress {
    get
  }
  @discardableResult
  open func uploadProgress(queue: Dispatch.DispatchQueue = DispatchQueue.main, closure: @escaping walletverse_ios_sdk.UploadRequest.ProgressHandler) -> Self
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 9.0, macOS 10.11, tvOS 9.0, *)
open class StreamRequest : walletverse_ios_sdk.ARequest {
  @objc deinit
}
public protocol DappWebviewDelegate {
  func DappMessageDelegate(json: SwiftyJSON.JSON?)
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class DappWebview : WebKit.WKWebView {
  @_Concurrency.MainActor(unsafe) public var progressView: UIKit.UIProgressView?
  @_Concurrency.MainActor(unsafe) public var dappModel: walletverse_ios_sdk.DappModel?
  @_Concurrency.MainActor(unsafe) public var dappDelegate: walletverse_ios_sdk.DappWebviewDelegate?
  @_Concurrency.MainActor(unsafe) public var chainAccount: walletverse_ios_sdk.WalletCoinModel?
  @_Concurrency.MainActor(unsafe) @objc dynamic public init(frame: CoreFoundation.CGRect)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func observeValue(forKeyPath keyPath: Swift.String?, of object: Any?, change: [Foundation.NSKeyValueChangeKey : Any]?, context: Swift.UnsafeMutableRawPointer?)
  @_Concurrency.MainActor(unsafe) public func methodCallback(id: Swift.String, err: Swift.String, data: Swift.String)
}
extension walletverse_ios_sdk.DappWebview : WebKit.WKNavigationDelegate, WebKit.WKUIDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation, withError error: Swift.Error)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_: WebKit.WKWebView, createWebViewWith _: WebKit.WKWebViewConfiguration, for navigationAction: WebKit.WKNavigationAction, windowFeatures _: WebKit.WKWindowFeatures) -> WebKit.WKWebView?
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_: WebKit.WKWebView, decidePolicyFor _: WebKit.WKNavigationResponse, decisionHandler: @escaping (WebKit.WKNavigationResponsePolicy) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_: WebKit.WKWebView, decidePolicyFor _: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, didCommit navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, didStartProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WebKit.WKNavigation!)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func webView(_ webView: WebKit.WKWebView, didFinish navigation: WebKit.WKNavigation!)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func restartInject()
  @_Concurrency.MainActor(unsafe) public func buildAccount()
  @_Concurrency.MainActor(unsafe) public func matchAccount(chain: Swift.String?, address: Swift.String?, rpc: Swift.String?, chainId: Swift.String?, url: Swift.String?, apiKey: Swift.String = "") -> Swift.String
}
extension walletverse_ios_sdk.DappWebview : WebKit.WKScriptMessageHandler {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func userContentController(_ userContentController: WebKit.WKUserContentController, didReceive message: WebKit.WKScriptMessage)
}
public struct DatabaseRegionObservation {
  public var extent: walletverse_ios_sdk.GDatabase.TransactionObservationExtent
  public init(tracking regions: walletverse_ios_sdk.DatabaseRegionConvertible...)
  public init(tracking regions: [walletverse_ios_sdk.DatabaseRegionConvertible])
}
extension walletverse_ios_sdk.DatabaseRegionObservation {
  public func start(in dbWriter: walletverse_ios_sdk.DatabaseWriter, onChange: @escaping (walletverse_ios_sdk.GDatabase) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver
}
public struct SQLCollatedExpression {
  public let expression: walletverse_ios_sdk.SQLExpression
  public let collationName: walletverse_ios_sdk.GDatabase.CollationName
  public var asc: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
  public var desc: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
}
extension walletverse_ios_sdk.SQLCollatedExpression : walletverse_ios_sdk.SQLOrderingTerm {
  public var reversed: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
  public func orderingTermSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func qualifiedOrdering(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLOrderingTerm
}
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func combine<R1, R2>(_ o1: walletverse_ios_sdk.ValueObservation<R1>, _ o2: walletverse_ios_sdk.ValueObservation<R2>) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.AnyValueReducer<(R1.Fetched, R2.Fetched), (R1.Value, R2.Value)>> where R1 : walletverse_ios_sdk.ValueReducer, R2 : walletverse_ios_sdk.ValueReducer
  public static func combine<R1, R2, R3>(_ o1: walletverse_ios_sdk.ValueObservation<R1>, _ o2: walletverse_ios_sdk.ValueObservation<R2>, _ o3: walletverse_ios_sdk.ValueObservation<R3>) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.AnyValueReducer<(R1.Fetched, R2.Fetched, R3.Fetched), (R1.Value, R2.Value, R3.Value)>> where R1 : walletverse_ios_sdk.ValueReducer, R2 : walletverse_ios_sdk.ValueReducer, R3 : walletverse_ios_sdk.ValueReducer
  public static func combine<R1, R2, R3, R4>(_ o1: walletverse_ios_sdk.ValueObservation<R1>, _ o2: walletverse_ios_sdk.ValueObservation<R2>, _ o3: walletverse_ios_sdk.ValueObservation<R3>, _ o4: walletverse_ios_sdk.ValueObservation<R4>) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.AnyValueReducer<(R1.Fetched, R2.Fetched, R3.Fetched, R4.Fetched), (R1.Value, R2.Value, R3.Value, R4.Value)>> where R1 : walletverse_ios_sdk.ValueReducer, R2 : walletverse_ios_sdk.ValueReducer, R3 : walletverse_ios_sdk.ValueReducer, R4 : walletverse_ios_sdk.ValueReducer
  public static func combine<R1, R2, R3, R4, R5>(_ o1: walletverse_ios_sdk.ValueObservation<R1>, _ o2: walletverse_ios_sdk.ValueObservation<R2>, _ o3: walletverse_ios_sdk.ValueObservation<R3>, _ o4: walletverse_ios_sdk.ValueObservation<R4>, _ o5: walletverse_ios_sdk.ValueObservation<R5>) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.AnyValueReducer<(R1.Fetched, R2.Fetched, R3.Fetched, R4.Fetched, R5.Fetched), (R1.Value, R2.Value, R3.Value, R4.Value, R5.Value)>> where R1 : walletverse_ios_sdk.ValueReducer, R2 : walletverse_ios_sdk.ValueReducer, R3 : walletverse_ios_sdk.ValueReducer, R4 : walletverse_ios_sdk.ValueReducer, R5 : walletverse_ios_sdk.ValueReducer
}
@_hasMissingDesignatedInitializers public class UserConfig {
  public var uuid: Swift.String?
  public var language: walletverse_ios_sdk.Language?
  public var currency: walletverse_ios_sdk.Currency?
  public var cs: walletverse_ios_sdk.Unit?
  public init()
  @objc deinit
}
extension walletverse_ios_sdk.Row {
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch<Request>(_ db: walletverse_ios_sdk.GDatabase, _ request: Request) -> Any where Request : walletverse_ios_sdk.FetchRequest
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
}
extension walletverse_ios_sdk.DatabaseValueConvertible {
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch<Request>(_ db: walletverse_ios_sdk.GDatabase, _ request: Request) -> Any where Request : walletverse_ios_sdk.FetchRequest
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch<Request>(_ db: walletverse_ios_sdk.GDatabase, _ request: Request) -> Any where Request : walletverse_ios_sdk.FetchRequest
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
}
extension walletverse_ios_sdk.QueryInterfaceRequest {
  @available(*, unavailable, renamed: "fetchCursor")
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) -> Any
}
extension walletverse_ios_sdk.FetchableRecord {
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch<Request>(_ db: walletverse_ios_sdk.GDatabase, _ request: Request) -> Any where Request : walletverse_ios_sdk.FetchRequest
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) -> Any
}
extension walletverse_ios_sdk.FetchableRecord where Self : walletverse_ios_sdk.TableRecord {
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase) -> Any
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch<Sequence>(_ db: walletverse_ios_sdk.GDatabase, keys: Sequence) -> Any where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  @available(*, unavailable, renamed: "fetchCursor")
  public static func fetch(_ db: walletverse_ios_sdk.GDatabase, keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) -> Any
}
@available(*, unavailable, message: "DatabaseSequence has been replaced by Cursor.")
public struct DatabaseSequence<T> {
}
@available(*, unavailable, message: "DatabaseIterator has been replaced by Cursor.")
public struct DatabaseIterator<T> {
}
public struct SaveCoinParams : walletverse_ios_sdk.HandyJSON {
  public var wid: Swift.String?
  public var pin: Swift.String?
  public var walletCoinModel: walletverse_ios_sdk.WalletCoinModel?
  public init()
  public init(wid: Swift.String? = nil, pin: Swift.String? = nil, walletCoinModel: walletverse_ios_sdk.WalletCoinModel? = nil)
}
public struct GetChainsParams : walletverse_ios_sdk.HandyJSON {
  public var vm: Swift.String?
  public init()
  public init(vm: Swift.String? = nil)
}
public struct DecodeMessageParams : walletverse_ios_sdk.HandyJSON {
  public var message: Swift.String?
  public var password: Swift.String?
  public init()
  public init(message: Swift.String? = nil, password: Swift.String? = nil)
}
public struct TokenParams : walletverse_ios_sdk.HandyJSON {
  public var page: Swift.String?
  public var size: Swift.String?
  public var chainId: Swift.String?
  public init()
  public init(page: Swift.String? = nil, size: Swift.String? = nil, chainId: Swift.String? = nil)
}
public struct GetTokenParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct TransactionRecordParams : walletverse_ios_sdk.HandyJSON {
  public var page: Swift.String?
  public var size: Swift.String?
  public var chainId: Swift.String?
  public var address: Swift.String?
  public var condition: walletverse_ios_sdk.Condition?
  public var contractAddress: Swift.String?
  public init()
  public init(page: Swift.String? = nil, size: Swift.String? = nil, chainId: Swift.String? = nil, address: Swift.String? = nil, condition: walletverse_ios_sdk.Condition? = nil, contractAddress: Swift.String? = nil)
}
public struct GetPriceParams : walletverse_ios_sdk.HandyJSON {
  public var symbol: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(symbol: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct FederatedParams : walletverse_ios_sdk.HandyJSON {
  public var providerKey: Swift.String?
  public var providerUid: Swift.String?
  public var providerId: Swift.String?
  public var auth: Swift.String?
  public init()
  public init(providerKey: Swift.String? = nil, providerUid: Swift.String? = nil, providerId: Swift.String? = nil, auth: Swift.String? = nil)
}
public struct ValidateAddressParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var address: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, address: Swift.String? = nil)
}
public struct ValidatePrivateKeyParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var privateKey: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, privateKey: Swift.String? = nil)
}
public struct ValidateMnemonicParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var mnemonic: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, mnemonic: Swift.String? = nil)
}
public struct SignMessageParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var privateKey: Swift.String?
  public var message: walletverse_ios_sdk.DAppMessageParams?
  public init()
  public init(chainId: Swift.String? = nil, privateKey: Swift.String? = nil, message: walletverse_ios_sdk.DAppMessageParams? = nil)
}
public struct DAppMessageParams : walletverse_ios_sdk.HandyJSON {
  public var data: Swift.String?
  public var __type: Swift.String?
  public var privateKey: Swift.String?
  public var nonce: Swift.String?
  public init()
  public init(data: Swift.String? = nil, __type: Swift.String? = nil, privateKey: Swift.String? = nil, nonce: Swift.String? = nil)
}
public struct SignTransactionParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var privateKey: Swift.String?
  public var to: Swift.String?
  public var value: Swift.String?
  public var decimals: Swift.Int?
  public var gasPrice: Swift.String?
  public var gasLimit: Swift.String?
  public var nonce: Swift.String?
  public var inputData: Swift.String?
  public var contractAddress: Swift.String?
  public init(chainId: Swift.String? = nil, privateKey: Swift.String? = nil, to: Swift.String? = nil, value: Swift.String? = nil, decimals: Swift.Int? = nil, gasPrice: Swift.String? = nil, gasLimit: Swift.String? = nil, nonce: Swift.String? = nil, inputData: Swift.String? = nil, contractAddress: Swift.String? = nil)
  public init()
}
public struct SignAndTransactionParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var privateKey: Swift.String?
  public var from: Swift.String?
  public var to: Swift.String?
  public var value: Swift.String?
  public var decimals: Swift.Int?
  public var gasPrice: Swift.String?
  public var gasLimit: Swift.String?
  public var inputData: Swift.String?
  public var contractAddress: Swift.String?
  public var walletPin: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, privateKey: Swift.String? = nil, from: Swift.String? = nil, to: Swift.String? = nil, value: Swift.String? = nil, decimals: Swift.Int? = nil, gasPrice: Swift.String? = nil, gasLimit: Swift.String? = nil, inputData: Swift.String? = nil, contractAddress: Swift.String? = nil, walletPin: Swift.String? = nil)
}
public struct GetParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var address: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, address: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct TransactionParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var from: Swift.String?
  public var to: Swift.String?
  public var sign: Swift.String?
  public var value: Swift.String?
  public var contractAddress: Swift.String?
  public init(chainId: Swift.String? = nil, from: Swift.String? = nil, to: Swift.String? = nil, sign: Swift.String? = nil, value: Swift.String? = nil, contractAddress: Swift.String? = nil)
  public init()
}
public struct EncodeERC20ABIParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var contractMethod: Swift.String?
  public var contractAddress: Swift.String?
  public var params: [Swift.String]?
  public var abi: [[Swift.String : Any]]?
  public init()
  public init(chainId: Swift.String? = nil, contractMethod: Swift.String? = nil, contractAddress: Swift.String? = nil, params: [Swift.String]? = nil, abi: [[Swift.String : Any]]? = nil)
}
public struct CreateWeb2Params : walletverse_ios_sdk.HandyJSON {
  public var mnemonic: Swift.String?
  public var wallets: [walletverse_ios_sdk.Coin]?
  public var walletName: Swift.String?
  public var walletPin: Swift.String?
  public var password: Swift.String?
  public var federatedParams: walletverse_ios_sdk.FederatedParams?
  public init()
  public init(mnemonic: Swift.String? = nil, wallets: [walletverse_ios_sdk.Coin]? = nil, walletName: Swift.String? = nil, walletPin: Swift.String? = nil, password: Swift.String? = nil, federatedParams: walletverse_ios_sdk.FederatedParams? = nil)
}
public struct RestoreWeb2Params : walletverse_ios_sdk.HandyJSON {
  public var shards: [Swift.String]?
  public var wallets: [walletverse_ios_sdk.Coin]?
  public var walletName: Swift.String?
  public var walletPin: Swift.String?
  public var password: Swift.String?
  public var federatedParams: walletverse_ios_sdk.FederatedParams?
  public init()
  public init(shards: [Swift.String]? = nil, wallets: [walletverse_ios_sdk.Coin]? = nil, walletName: Swift.String? = nil, walletPin: Swift.String? = nil, password: Swift.String? = nil, federatedParams: walletverse_ios_sdk.FederatedParams? = nil)
}
public struct EmailCodeParams : walletverse_ios_sdk.HandyJSON {
  public var vcode: Swift.String?
  public var text: Swift.String?
  public var type: Swift.String?
  public var account: Swift.String?
  public init(vcode: Swift.String? = nil, text: Swift.String? = nil, type: Swift.String? = nil, account: Swift.String? = nil)
  public init()
}
public struct EmailVerifyParams : walletverse_ios_sdk.HandyJSON {
  public var vcode: Swift.String?
  public var account: Swift.String?
  public init(vcode: Swift.String? = nil, account: Swift.String? = nil)
  public init()
}
public struct InitChainParams : walletverse_ios_sdk.HandyJSON {
  public var wid: Swift.String?
  public var address: Swift.String?
  public var privateKey: Swift.String?
  public var walletPin: Swift.String?
  public var chainId: Swift.String?
  public var contract: Swift.String?
  public var symbol: Swift.String?
  public init(wid: Swift.String? = nil, address: Swift.String? = nil, privateKey: Swift.String? = nil, walletPin: Swift.String? = nil, chainId: Swift.String? = nil, contract: Swift.String? = nil, symbol: Swift.String? = nil)
  public init()
}
public struct ChainNonce : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var address: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, address: Swift.String? = nil)
}
public struct CoinBalance : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var address: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, address: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct CoinDecimals : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct ChainGasPrice : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil)
}
public struct CoinFee : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var from: Swift.String?
  public var to: Swift.String?
  public var value: Swift.String?
  public var decimals: Swift.String?
  public var data: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, from: Swift.String? = nil, to: Swift.String? = nil, value: Swift.String? = nil, decimals: Swift.String? = nil, data: Swift.String? = nil)
}
public struct NftItemsParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var address: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, address: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct NftDetailParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var tokenId: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, tokenId: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
public struct NftTransferDataParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var tokenId: Swift.String?
  public var contractAddress: Swift.String?
  public var from: Swift.String?
  public var to: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, tokenId: Swift.String? = nil, contractAddress: Swift.String? = nil, from: Swift.String? = nil, to: Swift.String? = nil)
}
public struct NftTokenURIParams : walletverse_ios_sdk.HandyJSON {
  public var chainId: Swift.String?
  public var tokenId: Swift.String?
  public var contractAddress: Swift.String?
  public init()
  public init(chainId: Swift.String? = nil, tokenId: Swift.String? = nil, contractAddress: Swift.String? = nil)
}
@available(*, unavailable, renamed: "Database.ForeignKeyAction")
public typealias SQLForeignKeyAction = walletverse_ios_sdk.GDatabase.ForeignKeyAction
@available(*, unavailable, renamed: "Database.ColumnType")
public typealias SQLColumnType = walletverse_ios_sdk.GDatabase.ColumnType
@available(*, unavailable, renamed: "Database.ConflictResolution")
public typealias SQLConflictResolution = walletverse_ios_sdk.GDatabase.ConflictResolution
@available(*, unavailable, renamed: "Database.CollationName")
public typealias SQLCollation = walletverse_ios_sdk.GDatabase.CollationName
@available(*, unavailable, renamed: "SQLSpecificExpressible")
public typealias _SpecificSQLExpressible = walletverse_ios_sdk.SQLSpecificExpressible
@available(*, unavailable, renamed: "SQLExpression")
public typealias _SQLExpression = walletverse_ios_sdk.SQLExpression
public enum RResult<Value, Error> : walletverse_ios_sdk.ResultProtocol, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible where Error : Swift.Error {
  case success(Value)
  case failure(Error)
  public typealias Success = Value
  public typealias Failure = Error
  public init(value: Value)
  public init(error: Error)
  public init(_ value: Value?, failWith: @autoclosure () -> Error)
  public init(_ f: @autoclosure () throws -> Value)
  @available(*, deprecated, renamed: "init(catching:)")
  public init(attempt f: () throws -> Value)
  public init(catching body: () throws -> walletverse_ios_sdk.RResult<Value, Error>.Success)
  @available(*, deprecated, renamed: "get()")
  public func dematerialize() throws -> Value
  public func get() throws -> walletverse_ios_sdk.RResult<Value, Error>.Success
  public func analysis<RResult>(ifSuccess: (Value) -> RResult, ifFailure: (Error) -> RResult) -> RResult
  public static var errorDomain: Swift.String {
    get
  }
  public static var functionKey: Swift.String {
    get
  }
  public static var fileKey: Swift.String {
    get
  }
  public static var lineKey: Swift.String {
    get
  }
  public static func error(_ message: Swift.String? = nil, function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line) -> Foundation.NSError
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var result: walletverse_ios_sdk.RResult<Value, Error> {
    get
  }
}
extension walletverse_ios_sdk.RResult where Error == walletverse_ios_sdk.AnyError {
  public init(_ f: @autoclosure () throws -> Value)
  public init(attempt f: () throws -> Value)
}
@available(*, deprecated, renamed: "Result.init(attempt:)")
public func materialize<T>(_ f: () throws -> T) -> walletverse_ios_sdk.RResult<T, walletverse_ios_sdk.AnyError>
@available(*, deprecated, renamed: "Result.init(_:)")
public func materialize<T>(_ f: @autoclosure () throws -> T) -> walletverse_ios_sdk.RResult<T, walletverse_ios_sdk.AnyError>
extension Foundation.NSError : walletverse_ios_sdk.ErrorConvertible {
  public static func error(from error: Swift.Error) -> Self
}
@available(*, unavailable, message: "Use the overload which returns `Result<T, AnyError>` instead")
public func materialize<T>(_ f: () throws -> T) -> walletverse_ios_sdk.RResult<T, Foundation.NSError>
@available(*, unavailable, message: "Use the overload which returns `Result<T, AnyError>` instead")
public func materialize<T>(_ f: @autoclosure () throws -> T) -> walletverse_ios_sdk.RResult<T, Foundation.NSError>
@available(*, unavailable, message: "This has been removed. Use `Result.init(attempt:)` instead. See https://github.com/antitypical/Result/issues/85 for the details.")
public func `try`<T>(_ function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line, try: (Foundation.NSErrorPointer) -> T?) -> walletverse_ios_sdk.RResult<T, Foundation.NSError>
@available(*, unavailable, message: "This has been removed. Use `Result.init(attempt:)` instead. See https://github.com/antitypical/Result/issues/85 for the details.")
public func `try`(_ function: Swift.String = #function, file: Swift.String = #file, line: Swift.Int = #line, try: (Foundation.NSErrorPointer) -> Swift.Bool) -> walletverse_ios_sdk.RResult<(), Foundation.NSError>
public struct DatabaseValue : Swift.Hashable, Swift.CustomStringConvertible, walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.SQLExpression {
  public let storage: walletverse_ios_sdk.DatabaseValue.Storage
  public static let null: walletverse_ios_sdk.DatabaseValue
  public enum Storage : Swift.Equatable {
    case null
    case int64(Swift.Int64)
    case double(Swift.Double)
    case string(Swift.String)
    case blob(Foundation.Data)
    public var value: walletverse_ios_sdk.DatabaseValueConvertible? {
      get
    }
    public static func == (lhs: walletverse_ios_sdk.DatabaseValue.Storage, rhs: walletverse_ios_sdk.DatabaseValue.Storage) -> Swift.Bool
  }
  public init?(value: Any)
  public var isNull: Swift.Bool {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension walletverse_ios_sdk.DatabaseValue {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: walletverse_ios_sdk.DatabaseValue, rhs: walletverse_ios_sdk.DatabaseValue) -> Swift.Bool
}
extension walletverse_ios_sdk.DatabaseValue {
  public func losslessConvert<T>(sql: Swift.String? = nil, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> T where T : walletverse_ios_sdk.DatabaseValueConvertible
  public func losslessConvert<T>(sql: Swift.String? = nil, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> T? where T : walletverse_ios_sdk.DatabaseValueConvertible
}
extension walletverse_ios_sdk.DatabaseValue {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> walletverse_ios_sdk.DatabaseValue?
}
extension walletverse_ios_sdk.DatabaseValue {
  public var sqlExpression: walletverse_ios_sdk.SQLExpression {
    get
  }
}
extension walletverse_ios_sdk.DatabaseValue {
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public var negated: walletverse_ios_sdk.SQLExpression {
    get
  }
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
extension walletverse_ios_sdk.DatabaseValue {
  public var description: Swift.String {
    get
  }
}
public struct ForeignKey {
  public init(_ originColumns: [Swift.String], to destinationColumns: [Swift.String]? = nil)
  public init(_ originColumns: [walletverse_ios_sdk.ColumnExpression], to destinationColumns: [walletverse_ios_sdk.ColumnExpression]? = nil)
}
extension CoreFoundation.CGFloat : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> CoreFoundation.CGFloat?
}
public enum AResult<Value> {
  case success(Value)
  case failure(Swift.Error)
  public var isSuccess: Swift.Bool {
    get
  }
  public var isFailure: Swift.Bool {
    get
  }
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
}
extension walletverse_ios_sdk.AResult : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.AResult : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.AResult {
  public init(value: () throws -> Value)
  public func unwrap() throws -> Value
  public func map<T>(_ transform: (Value) -> T) -> walletverse_ios_sdk.AResult<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> walletverse_ios_sdk.AResult<T>
  public func mapError<T>(_ transform: (Swift.Error) -> T) -> walletverse_ios_sdk.AResult<Value> where T : Swift.Error
  public func flatMapError<T>(_ transform: (Swift.Error) throws -> T) -> walletverse_ios_sdk.AResult<Value> where T : Swift.Error
  @discardableResult
  public func withValue(_ closure: (Value) throws -> Swift.Void) rethrows -> walletverse_ios_sdk.AResult<Value>
  @discardableResult
  public func withError(_ closure: (Swift.Error) throws -> Swift.Void) rethrows -> walletverse_ios_sdk.AResult<Value>
  @discardableResult
  public func ifSuccess(_ closure: () throws -> Swift.Void) rethrows -> walletverse_ios_sdk.AResult<Value>
  @discardableResult
  public func ifFailure(_ closure: () throws -> Swift.Void) rethrows -> walletverse_ios_sdk.AResult<Value>
}
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func trackingAll<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.FetchableRecordsReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.FetchableRecord
  public static func trackingOne<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.FetchableRecordReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.FetchableRecord
}
public struct FetchableRecordsReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.FetchableRecord {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.Row]
  public mutating func value(_ rows: [walletverse_ios_sdk.Row]) -> [Request.RowDecoder]?
  public typealias Fetched = [walletverse_ios_sdk.Row]
  public typealias Value = [Request.RowDecoder]
}
public struct FetchableRecordReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.FetchableRecord {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.Row?
  public mutating func value(_ row: walletverse_ios_sdk.Row?) -> Request.RowDecoder??
  public typealias Fetched = walletverse_ios_sdk.Row?
  public typealias Value = Request.RowDecoder?
}
public enum MultiTarget : walletverse_ios_sdk.TargetType {
  case target(walletverse_ios_sdk.TargetType)
  public init(_ target: walletverse_ios_sdk.TargetType)
  public var path: Swift.String {
    get
  }
  public var baseURL: Foundation.URL {
    get
  }
  public var method: walletverse_ios_sdk.Method {
    get
  }
  public var sampleData: Foundation.Data {
    get
  }
  public var task: walletverse_ios_sdk.Task {
    get
  }
  public var validationType: walletverse_ios_sdk.ValidationType {
    get
  }
  public var headers: [Swift.String : Swift.String]? {
    get
  }
  public var target: walletverse_ios_sdk.TargetType {
    get
  }
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Swift.Encodable {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Swift.Encodable, Self : Swift.RawRepresentable, Self.RawValue : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(walletverse_ios_sdk.NetworkReachabilityManager.ConnectionType)
  }
  public enum ConnectionType {
    case ethernetOrWiFi
    case wwan
    public static func == (a: walletverse_ios_sdk.NetworkReachabilityManager.ConnectionType, b: walletverse_ios_sdk.NetworkReachabilityManager.ConnectionType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias Listener = (walletverse_ios_sdk.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnWWAN: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  open var networkReachabilityStatus: walletverse_ios_sdk.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  open var listenerQueue: Dispatch.DispatchQueue
  open var listener: walletverse_ios_sdk.NetworkReachabilityManager.Listener?
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var previousFlags: SystemConfiguration.SCNetworkReachabilityFlags
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening() -> Swift.Bool
  open func stopListening()
}
extension walletverse_ios_sdk.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
}
public func == (lhs: walletverse_ios_sdk.NetworkReachabilityManager.NetworkReachabilityStatus, rhs: walletverse_ios_sdk.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
public struct ChainModel : walletverse_ios_sdk.HandyJSON {
  public var address: Swift.String?
  public var rpcUrl: Swift.String?
  public var chainId: Swift.String?
  public var apiKey: Swift.String?
  public init()
  public init(address: Swift.String? = nil, rpcUrl: Swift.String? = nil, chainId: Swift.String? = nil, apiKey: Swift.String? = nil)
}
public struct Timeline {
  public let requestStartTime: CoreFoundation.CFAbsoluteTime
  public let initialResponseTime: CoreFoundation.CFAbsoluteTime
  public let requestCompletedTime: CoreFoundation.CFAbsoluteTime
  public let serializationCompletedTime: CoreFoundation.CFAbsoluteTime
  public let latency: Foundation.TimeInterval
  public let requestDuration: Foundation.TimeInterval
  public let serializationDuration: Foundation.TimeInterval
  public let totalDuration: Foundation.TimeInterval
  public init(requestStartTime: CoreFoundation.CFAbsoluteTime = 0.0, initialResponseTime: CoreFoundation.CFAbsoluteTime = 0.0, requestCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0, serializationCompletedTime: CoreFoundation.CFAbsoluteTime = 0.0)
}
extension walletverse_ios_sdk.Timeline : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.Timeline : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
open class DateFormatterTransform : walletverse_ios_sdk.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
public struct SQLRelation {
}
public enum JoinOperator {
  case required, optional
  public static func == (a: walletverse_ios_sdk.JoinOperator, b: walletverse_ios_sdk.JoinOperator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct JoinCondition : Swift.Equatable {
  public static func == (a: walletverse_ios_sdk.JoinCondition, b: walletverse_ios_sdk.JoinCondition) -> Swift.Bool
}
extension Foundation.NSDate : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension Foundation.Date : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Foundation.Date?
  public init?(julianDay: Swift.Double)
}
extension Foundation.Date : walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
}
extension walletverse_ios_sdk.ValueObservation where Reducer : walletverse_ios_sdk.ValueReducer {
  public func map<T>(_ transform: @escaping (Reducer.Value) -> T) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.MapValueReducer<Reducer, T>>
}
extension walletverse_ios_sdk.ValueReducer {
  public func map<T>(_ transform: @escaping (Self.Value) -> T) -> walletverse_ios_sdk.MapValueReducer<Self, T>
}
public struct MapValueReducer<Base, T> : walletverse_ios_sdk.ValueReducer where Base : walletverse_ios_sdk.ValueReducer {
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Base.Fetched
  public mutating func value(_ fetched: Base.Fetched) -> T?
  public typealias Fetched = Base.Fetched
  public typealias Value = T
}
extension walletverse_ios_sdk.DatabaseFunction {
  final public func apply(_ arguments: walletverse_ios_sdk.SQLExpressible...) -> walletverse_ios_sdk.SQLExpression
}
extension walletverse_ios_sdk.SQLFunctionName {
  public static let abs: walletverse_ios_sdk.SQLFunctionName
}
public func abs(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let avg: walletverse_ios_sdk.SQLFunctionName
}
public func average(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
public func count(_ counted: walletverse_ios_sdk.SQLSelectable) -> walletverse_ios_sdk.SQLExpression
public func count(distinct value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let ifNull: walletverse_ios_sdk.SQLFunctionName
}
public func ?? (lhs: walletverse_ios_sdk.SQLSpecificExpressible, rhs: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let length: walletverse_ios_sdk.SQLFunctionName
}
public func length(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let max: walletverse_ios_sdk.SQLFunctionName
}
public func max(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let min: walletverse_ios_sdk.SQLFunctionName
}
public func min(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLFunctionName {
  public static let sum: walletverse_ios_sdk.SQLFunctionName
}
public func sum(_ value: walletverse_ios_sdk.SQLSpecificExpressible) -> walletverse_ios_sdk.SQLExpression
extension walletverse_ios_sdk.SQLSpecificExpressible {
  public var capitalized: walletverse_ios_sdk.SQLExpression {
    get
  }
  public var lowercased: walletverse_ios_sdk.SQLExpression {
    get
  }
  public var uppercased: walletverse_ios_sdk.SQLExpression {
    get
  }
}
extension walletverse_ios_sdk.SQLSpecificExpressible {
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public var localizedCapitalized: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public var localizedLowercased: walletverse_ios_sdk.SQLExpression {
    get
  }
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public var localizedUppercased: walletverse_ios_sdk.SQLExpression {
    get
  }
}
public let Chains: [Swift.String : [Swift.String : Swift.String]]
extension walletverse_ios_sdk.HandyJSON {
  public static func deserialize(from dict: Foundation.NSDictionary?, designatedPath: Swift.String? = nil) -> Self?
  public static func deserialize(from dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil) -> Self?
  public static func deserialize(from json: Swift.String?, designatedPath: Swift.String? = nil) -> Self?
}
extension Swift.Array where Element : walletverse_ios_sdk.HandyJSON {
  public static func deserialize(from json: Swift.String?, designatedPath: Swift.String? = nil) -> [Element?]?
  public static func deserialize(from array: Foundation.NSArray?) -> [Element?]?
  public static func deserialize(from array: [Any]?) -> [Element?]?
}
@_hasMissingDesignatedInitializers public class JSONDeserializer<T> where T : walletverse_ios_sdk.HandyJSON {
  public static func deserializeFrom(dict: Foundation.NSDictionary?, designatedPath: Swift.String? = nil) -> T?
  public static func deserializeFrom(dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil) -> T?
  public static func deserializeFrom(json: Swift.String?, designatedPath: Swift.String? = nil) -> T?
  public static func update(object: inout T, from dict: [Swift.String : Any]?, designatedPath: Swift.String? = nil)
  public static func update(object: inout T, from json: Swift.String?, designatedPath: Swift.String? = nil)
  public static func deserializeModelArrayFrom(json: Swift.String?, designatedPath: Swift.String? = nil) -> [T?]?
  public static func deserializeModelArrayFrom(array: Foundation.NSArray?) -> [T?]?
  public static func deserializeModelArrayFrom(array: [Any]?) -> [T?]?
  @objc deinit
}
public typealias ImageType = UIKit.UIImage
public typealias Image = walletverse_ios_sdk.ImageType
public struct CoinAddModel : walletverse_ios_sdk.HandyJSON {
  public init()
}
public struct Coin : walletverse_ios_sdk.HandyJSON {
  public var id: Swift.Int64
  public var chainId: Swift.String?
  public var wid: Swift.String?
  public var address: Swift.String?
  public var privateKey: Swift.String?
  public var symbol: Swift.String?
  public var name: Swift.String?
  public var contract: Swift.String?
  public var contractAddress: Swift.String?
  public var iconUrl: Swift.String?
  public var balance: Swift.String?
  public var price: Swift.String?
  public var totalPrice: Swift.String?
  public var extra: Swift.String?
  public var chainName: Swift.String?
  public var scanUrl: Swift.String?
  public var rpcUrl: Swift.String?
  public var decimals: Swift.String?
  public var type: Swift.String?
  public var vm: Swift.String?
  public var isAdd: Swift.Bool
  public var lib: Swift.String?
  public var color: Swift.String?
  public var weth: Swift.String?
  public var scanDelay: Swift.String?
  public init()
  public init(id: Swift.Int64, chainId: Swift.String? = nil, wid: Swift.String? = nil, address: Swift.String? = nil, privateKey: Swift.String? = nil, symbol: Swift.String? = nil, name: Swift.String? = nil, contract: Swift.String? = nil, contractAddress: Swift.String? = nil, iconUrl: Swift.String? = nil, balance: Swift.String? = nil, price: Swift.String? = nil, totalPrice: Swift.String? = nil, extra: Swift.String? = nil, chainName: Swift.String? = nil, scanUrl: Swift.String? = nil, rpcUrl: Swift.String? = nil, decimals: Swift.String? = nil, type: Swift.String? = nil, vm: Swift.String? = nil, isAdd: Swift.Bool, lib: Swift.String? = nil, color: Swift.String? = nil, weth: Swift.String? = nil, scanDelay: Swift.String? = nil)
}
public struct ChainChainsModel : walletverse_ios_sdk.HandyJSON {
  public var items: Swift.Array<walletverse_ios_sdk.Coin>?
  public init()
  public init(items: Swift.Array<walletverse_ios_sdk.Coin>? = nil)
}
public struct CoinListModel : walletverse_ios_sdk.HandyJSON {
  public var items: Swift.Array<walletverse_ios_sdk.Coin>?
  public init()
  public init(items: Swift.Array<walletverse_ios_sdk.Coin>? = nil)
}
public struct TransactionListModel : walletverse_ios_sdk.HandyJSON {
  public var items: Swift.Array<walletverse_ios_sdk.TransactionRecord>?
  public init()
  public init(items: Swift.Array<walletverse_ios_sdk.TransactionRecord>? = nil)
}
public struct TransactionRecord : walletverse_ios_sdk.HandyJSON {
  public var symbol: Swift.String?
  public var blockHash: Swift.String?
  public var blockNumber: Swift.String?
  public var contract: Swift.String?
  public var from: Swift.String?
  public var gas: Swift.String?
  public var gasLimit: Swift.String?
  public var gasPrice: Swift.String?
  public var hash: Swift.String?
  public var input: Swift.String?
  public var nonce: Swift.String?
  public var scanAddressUrl: Swift.String?
  public var scanUrl: Swift.String?
  public var timestamp: Swift.String?
  public var to: Swift.String?
  public var type: Swift.String?
  public var value: Swift.String?
  public var status: Swift.String?
  public init()
  public init(symbol: Swift.String? = nil, blockHash: Swift.String? = nil, blockNumber: Swift.String? = nil, contract: Swift.String? = nil, from: Swift.String? = nil, gas: Swift.String? = nil, gasLimit: Swift.String? = nil, gasPrice: Swift.String? = nil, hash: Swift.String? = nil, input: Swift.String? = nil, nonce: Swift.String? = nil, scanAddressUrl: Swift.String? = nil, scanUrl: Swift.String? = nil, timestamp: Swift.String? = nil, to: Swift.String? = nil, type: Swift.String? = nil, value: Swift.String? = nil, status: Swift.String? = nil)
}
public struct CoinPriceModel : walletverse_ios_sdk.HandyJSON {
  public var price: Swift.String?
  public init()
  public init(price: Swift.String? = nil)
}
public struct ChainSendModel : walletverse_ios_sdk.HandyJSON {
  public var hash: Swift.String?
  public init()
  public init(hash: Swift.String? = nil)
}
public struct UserprofileModel : walletverse_ios_sdk.HandyJSON {
  public var wid: Swift.String?
  public var shards: [Swift.String]?
  public var wallets: [walletverse_ios_sdk.Coin]?
  public init()
  public init(wid: Swift.String? = nil, shards: [Swift.String]? = nil, wallets: [walletverse_ios_sdk.Coin]? = nil)
}
public struct EmailCodeModel : walletverse_ios_sdk.HandyJSON {
  public var data: Swift.String?
  public var text: Swift.String?
  public init()
  public init(data: Swift.String? = nil, text: Swift.String? = nil)
}
public struct DefaultModel : walletverse_ios_sdk.HandyJSON {
  public var result: Swift.Bool?
  public var auth: Swift.String?
  public init()
  public init(result: Swift.Bool? = nil, auth: Swift.String? = nil)
}
public struct NativeModel : walletverse_ios_sdk.HandyJSON {
  public var code: Swift.String?
  public var msg: Swift.String?
  public var data: Swift.String?
  public init()
  public init(code: Swift.String? = nil, msg: Swift.String? = nil, data: Swift.String? = nil)
}
public struct ChainNonceModel : walletverse_ios_sdk.HandyJSON {
  public var nonce: Swift.String?
  public init()
  public init(nonce: Swift.String? = nil)
}
public struct CoinBalanceModel : walletverse_ios_sdk.HandyJSON {
  public var balance: Swift.String?
  public init()
  public init(balance: Swift.String? = nil)
}
public struct CoinDecimalsModel : walletverse_ios_sdk.HandyJSON {
  public var decimals: Swift.String?
  public init()
  public init(decimals: Swift.String? = nil)
}
public struct ChainGasPriceModel : walletverse_ios_sdk.HandyJSON {
  public var gasprice: Swift.String?
  public init()
  public init(gasprice: Swift.String? = nil)
}
public struct ChainFeeModel : walletverse_ios_sdk.HandyJSON {
  public var gasPrice: Swift.String?
  public var gasLimit: Swift.String?
  public init()
  public init(gasPrice: Swift.String? = nil, gasLimit: Swift.String? = nil)
}
public struct NftItemsModel : walletverse_ios_sdk.HandyJSON {
  public var items: Swift.Array<walletverse_ios_sdk.NftModel>?
  public init()
  public init(items: Swift.Array<walletverse_ios_sdk.NftModel>? = nil)
}
public struct NftModel : walletverse_ios_sdk.HandyJSON {
  public var address: Swift.String?
  public var chainId: Swift.String?
  public var contractAddress: Swift.String?
  public var ct: Swift.String?
  public var external_url: Swift.String?
  public var id: Swift.String?
  public var image: Swift.String?
  public var name: Swift.String?
  public var tokenId: Swift.String?
  public var url: Swift.String?
  public var ut: Swift.String?
  public var attributes: Swift.Array<walletverse_ios_sdk.NftAttribute>?
  public init()
  public init(address: Swift.String? = nil, chainId: Swift.String? = nil, contractAddress: Swift.String? = nil, ct: Swift.String? = nil, external_url: Swift.String? = nil, id: Swift.String? = nil, image: Swift.String? = nil, name: Swift.String? = nil, tokenId: Swift.String? = nil, url: Swift.String? = nil, ut: Swift.String? = nil, attributes: Swift.Array<walletverse_ios_sdk.NftAttribute>? = nil)
}
public struct NftAttribute : walletverse_ios_sdk.HandyJSON {
  public var trait_type: Swift.String?
  public var value: Swift.String?
  public init()
  public init(trait_type: Swift.String? = nil, value: Swift.String? = nil)
}
public struct NftTransferDataModel : walletverse_ios_sdk.HandyJSON {
  public var inputData: Swift.String?
  public init()
  public init(inputData: Swift.String? = nil)
}
public struct NftTokenURIModel : walletverse_ios_sdk.HandyJSON {
  public var tokenURI: Swift.String?
  public init()
  public init(tokenURI: Swift.String? = nil)
}
public protocol ValueReducer {
  associatedtype Fetched
  associatedtype Value
  func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Self.Fetched
  mutating func value(_ fetched: Self.Fetched) -> Self.Value?
}
public struct AnyValueReducer<Fetched, Value> : walletverse_ios_sdk.ValueReducer {
  public init(fetch: @escaping (walletverse_ios_sdk.GDatabase) throws -> Fetched, value: @escaping (Fetched) -> Value?)
  public init<Base>(_ reducer: Base) where Fetched == Base.Fetched, Value == Base.Value, Base : walletverse_ios_sdk.ValueReducer
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Fetched
  public func value(_ fetched: Fetched) -> Value?
}
public struct RawValueReducer<Value> : walletverse_ios_sdk.ValueReducer {
  public init(_ fetch: @escaping (walletverse_ios_sdk.GDatabase) throws -> Value)
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Value
  public func value(_ fetched: Value) -> Value?
  public typealias Fetched = Value
}
public struct AnyError : Swift.Error {
  public let error: Swift.Error
  public init(_ error: Swift.Error)
}
extension walletverse_ios_sdk.AnyError : walletverse_ios_sdk.ErrorConvertible {
  public static func error(from error: Swift.Error) -> walletverse_ios_sdk.AnyError
}
extension walletverse_ios_sdk.AnyError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.AnyError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
  public var helpAnchor: Swift.String? {
    get
  }
  public var recoverySuggestion: Swift.String? {
    get
  }
}
public enum HTTPMethod : Swift.String {
  case options
  case get
  case head
  case post
  case put
  case patch
  case delete
  case trace
  case connect
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, with parameters: walletverse_ios_sdk.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : walletverse_ios_sdk.ParameterEncoding {
  public enum Destination {
    case methodDependent, queryString, httpBody
    public static func == (a: walletverse_ios_sdk.URLEncoding.Destination, b: walletverse_ios_sdk.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets, noBrackets
    public static func == (a: walletverse_ios_sdk.URLEncoding.ArrayEncoding, b: walletverse_ios_sdk.URLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric, literal
    public static func == (a: walletverse_ios_sdk.URLEncoding.BoolEncoding, b: walletverse_ios_sdk.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: walletverse_ios_sdk.URLEncoding {
    get
  }
  public static var methodDependent: walletverse_ios_sdk.URLEncoding {
    get
  }
  public static var queryString: walletverse_ios_sdk.URLEncoding {
    get
  }
  public static var httpBody: walletverse_ios_sdk.URLEncoding {
    get
  }
  public let destination: walletverse_ios_sdk.URLEncoding.Destination
  public let arrayEncoding: walletverse_ios_sdk.URLEncoding.ArrayEncoding
  public let boolEncoding: walletverse_ios_sdk.URLEncoding.BoolEncoding
  public init(destination: walletverse_ios_sdk.URLEncoding.Destination = .methodDependent, arrayEncoding: walletverse_ios_sdk.URLEncoding.ArrayEncoding = .brackets, boolEncoding: walletverse_ios_sdk.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, with parameters: walletverse_ios_sdk.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : walletverse_ios_sdk.ParameterEncoding {
  public static var `default`: walletverse_ios_sdk.JSONEncoding {
    get
  }
  public static var prettyPrinted: walletverse_ios_sdk.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, with parameters: walletverse_ios_sdk.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public struct PropertyListEncoding : walletverse_ios_sdk.ParameterEncoding {
  public static var `default`: walletverse_ios_sdk.PropertyListEncoding {
    get
  }
  public static var xml: walletverse_ios_sdk.PropertyListEncoding {
    get
  }
  public static var binary: walletverse_ios_sdk.PropertyListEncoding {
    get
  }
  public let format: Foundation.PropertyListSerialization.PropertyListFormat
  public let options: Foundation.PropertyListSerialization.WriteOptions
  public init(format: Foundation.PropertyListSerialization.PropertyListFormat = .xml, options: Foundation.PropertyListSerialization.WriteOptions = 0)
  public func encode(_ urlRequest: walletverse_ios_sdk.URLRequestConvertible, with parameters: walletverse_ios_sdk.Parameters?) throws -> Foundation.URLRequest
}
public protocol SelectionRequest {
  func select(_ selection: [walletverse_ios_sdk.SQLSelectable]) -> Self
}
extension walletverse_ios_sdk.SelectionRequest {
  public func select(_ selection: walletverse_ios_sdk.SQLSelectable...) -> Self
  public func select(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> Self
}
public protocol FilteredRequest {
  func filter(_ predicate: @escaping (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.SQLExpressible) -> Self
}
extension walletverse_ios_sdk.FilteredRequest {
  public func filter(_ predicate: walletverse_ios_sdk.SQLExpressible) -> Self
  public func filter(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> Self
  public func none() -> Self
}
public protocol TableRequest {
  var databaseTableName: Swift.String { get }
  func aliased(_ alias: walletverse_ios_sdk.TableAlias) -> Self
}
extension walletverse_ios_sdk.TableRequest where Self : walletverse_ios_sdk.FilteredRequest {
  public func filter<PrimaryKeyType>(key: PrimaryKeyType?) -> Self where PrimaryKeyType : walletverse_ios_sdk.DatabaseValueConvertible
  public func filter<Sequence>(keys: Sequence) -> Self where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  public func filter(key: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]?) -> Self
  public func filter(keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) -> Self
}
extension walletverse_ios_sdk.TableRequest where Self : walletverse_ios_sdk.OrderedRequest {
  public func orderByPrimaryKey() -> Self
}
extension walletverse_ios_sdk.TableRequest where Self : walletverse_ios_sdk.AggregatingRequest {
  public func groupByPrimaryKey() -> Self
}
public protocol AggregatingRequest {
  func group(_ expressions: @escaping (walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.SQLExpressible]) -> Self
  func having(_ predicate: walletverse_ios_sdk.SQLExpressible) -> Self
}
extension walletverse_ios_sdk.AggregatingRequest {
  public func group(_ expressions: [walletverse_ios_sdk.SQLExpressible]) -> Self
  public func group(_ expressions: walletverse_ios_sdk.SQLExpressible...) -> Self
  public func group(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> Self
  public func having(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> Self
}
public protocol OrderedRequest {
  func order(_ orderings: @escaping (walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.SQLOrderingTerm]) -> Self
  func reversed() -> Self
}
extension walletverse_ios_sdk.OrderedRequest {
  public func order(_ orderings: walletverse_ios_sdk.SQLOrderingTerm...) -> Self
  public func order(_ orderings: [walletverse_ios_sdk.SQLOrderingTerm]) -> Self
  public func order(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> Self
}
public protocol DerivableRequest : walletverse_ios_sdk.FilteredRequest, walletverse_ios_sdk.OrderedRequest, walletverse_ios_sdk.SelectionRequest {
  associatedtype RowDecoder
}
final public class DatabasePool : walletverse_ios_sdk.DatabaseWriter {
  final public var path: Swift.String {
    get
  }
  public init(path: Swift.String, configuration: walletverse_ios_sdk.GConfiguration = GConfiguration()) throws
  @objc deinit
}
extension walletverse_ios_sdk.DatabasePool {
  final public func checkpoint(_ kind: walletverse_ios_sdk.GDatabase.CheckpointMode = .passive) throws
}
extension walletverse_ios_sdk.DatabasePool {
  final public func releaseMemory()
  final public func setupMemoryManagement(in application: UIKit.UIApplication)
}
extension walletverse_ios_sdk.DatabasePool : walletverse_ios_sdk.DatabaseReader {
  final public func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  @available(*, deprecated, message: "Use concurrentRead instead")
  final public func readFromCurrentState(_ block: @escaping (walletverse_ios_sdk.GDatabase) -> Swift.Void) throws
  final public func concurrentRead<T>(_ block: @escaping (walletverse_ios_sdk.GDatabase) throws -> T) -> walletverse_ios_sdk.Future<T>
  final public func write<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func writeWithoutTransaction<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func writeInTransaction(_ kind: walletverse_ios_sdk.GDatabase.TransactionKind? = nil, _ block: (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.GDatabase.TransactionCompletion) throws
  final public func unsafeReentrantWrite<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func add(function: walletverse_ios_sdk.DatabaseFunction)
  final public func remove(function: walletverse_ios_sdk.DatabaseFunction)
  final public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.DatabasePool {
  final public func makeSnapshot() throws -> walletverse_ios_sdk.DatabaseSnapshot
}
extension walletverse_ios_sdk.GDatabase {
  final public func add(transactionObserver: walletverse_ios_sdk.TransactionObserver, extent: walletverse_ios_sdk.GDatabase.TransactionObservationExtent = .observerLifetime)
  final public func remove(transactionObserver: walletverse_ios_sdk.TransactionObserver)
  final public func afterNextTransactionCommit(_ closure: @escaping (walletverse_ios_sdk.GDatabase) -> ())
  public enum TransactionObservationExtent {
    case observerLifetime
    case nextTransaction
    case databaseLifetime
    public static func == (a: walletverse_ios_sdk.GDatabase.TransactionObservationExtent, b: walletverse_ios_sdk.GDatabase.TransactionObservationExtent) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol TransactionObserver : AnyObject {
  func observes(eventsOfKind eventKind: walletverse_ios_sdk.DatabaseEventKind) -> Swift.Bool
  func databaseDidChange(with event: walletverse_ios_sdk.DatabaseEvent)
  func databaseWillCommit() throws
  func databaseDidCommit(_ db: walletverse_ios_sdk.GDatabase)
  func databaseDidRollback(_ db: walletverse_ios_sdk.GDatabase)
}
extension walletverse_ios_sdk.TransactionObserver {
  public func databaseWillCommit() throws
  public func stopObservingDatabaseChangesUntilNextTransaction()
}
public enum DatabaseEventKind {
  case insert(tableName: Swift.String)
  case delete(tableName: Swift.String)
  case update(tableName: Swift.String, columnNames: Swift.Set<Swift.String>)
}
extension walletverse_ios_sdk.DatabaseEventKind {
  public var tableName: Swift.String {
    get
  }
}
public struct DatabaseEvent {
  public enum Kind : Swift.Int32 {
    case insert
    case delete
    case update
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public let kind: walletverse_ios_sdk.DatabaseEvent.Kind
  public var databaseName: Swift.String {
    get
  }
  public var tableName: Swift.String {
    get
  }
  public let rowID: Swift.Int64
  public func copy() -> walletverse_ios_sdk.DatabaseEvent
}
public struct FTS3TokenizerDescriptor {
  public static let simple: walletverse_ios_sdk.FTS3TokenizerDescriptor
  public static let porter: walletverse_ios_sdk.FTS3TokenizerDescriptor
  @available(iOS 8.2, macOS 10.10, *)
  public static func unicode61(removeDiacritics: Swift.Bool = true, separators: Swift.Set<Swift.Character> = [], tokenCharacters: Swift.Set<Swift.Character> = []) -> walletverse_ios_sdk.FTS3TokenizerDescriptor
}
final public class DatabaseFunction : Swift.Hashable {
  final public var name: Swift.String {
    get
  }
  public init(_ name: Swift.String, argumentCount: Swift.Int32? = nil, pure: Swift.Bool = false, function: @escaping ([walletverse_ios_sdk.DatabaseValue]) throws -> walletverse_ios_sdk.DatabaseValueConvertible?)
  public init<Aggregate>(_ name: Swift.String, argumentCount: Swift.Int32? = nil, pure: Swift.Bool = false, aggregate: Aggregate.Type) where Aggregate : walletverse_ios_sdk.DatabaseAggregate
  @objc deinit
  final public var hashValue: Swift.Int {
    get
  }
}
extension walletverse_ios_sdk.DatabaseFunction {
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: walletverse_ios_sdk.DatabaseFunction, rhs: walletverse_ios_sdk.DatabaseFunction) -> Swift.Bool
}
public protocol DatabaseAggregate {
  init()
  mutating func step(_ dbValues: [walletverse_ios_sdk.DatabaseValue]) throws
  func finalize() throws -> walletverse_ios_sdk.DatabaseValueConvertible?
}
extension Foundation.NSString : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
public enum MoyaError : Swift.Error {
  case imageMapping(walletverse_ios_sdk.Response)
  case jsonMapping(walletverse_ios_sdk.Response)
  case stringMapping(walletverse_ios_sdk.Response)
  case objectMapping(Swift.Error, walletverse_ios_sdk.Response)
  case encodableMapping(Swift.Error)
  case statusCode(walletverse_ios_sdk.Response)
  case underlying(Swift.Error, walletverse_ios_sdk.Response?)
  case requestMapping(Swift.String)
  case parameterEncoding(Swift.Error)
}
extension walletverse_ios_sdk.MoyaError {
  public var response: walletverse_ios_sdk.Response? {
    get
  }
}
extension walletverse_ios_sdk.MoyaError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension walletverse_ios_sdk.MoyaError : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public struct DappModel : walletverse_ios_sdk.HandyJSON {
  public var wid: Swift.String?
  public var name: Swift.String?
  public var url: Swift.String?
  public var chain: Swift.String?
  public init()
  public init(wid: Swift.String? = nil, name: Swift.String? = nil, url: Swift.String? = nil, chain: Swift.String? = nil)
}
public protocol _RawEnumProtocol : walletverse_ios_sdk._Transformable {
  static func _transform(from object: Any) -> Self?
  func _plainValue() -> Any?
}
extension Swift.RawRepresentable where Self : walletverse_ios_sdk._RawEnumProtocol {
  public static func _transform(from object: Any) -> Self?
  public func _plainValue() -> Any?
}
public protocol DatabaseValueConvertible : walletverse_ios_sdk.SQLExpressible {
  var databaseValue: walletverse_ios_sdk.DatabaseValue { get }
  static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible {
  public var sqlExpression: walletverse_ios_sdk.SQLExpression {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DatabaseValueCursor<Value> : walletverse_ios_sdk.Cursor where Value : walletverse_ios_sdk.DatabaseValueConvertible {
  @objc deinit
  final public func next() throws -> Value?
  public typealias Element = Value
}
@_hasMissingDesignatedInitializers final public class NullableDatabaseValueCursor<Value> : walletverse_ios_sdk.Cursor where Value : walletverse_ios_sdk.DatabaseValueConvertible {
  @objc deinit
  final public func next() throws -> Value??
  public typealias Element = Value?
}
extension walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.DatabaseValueCursor<Self>
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.DatabaseValueCursor<Self>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.DatabaseValueCursor<Self> where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [Self] where R : walletverse_ios_sdk.FetchRequest
  public static func fetchOne<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> Self? where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseValueCursor<Self.RowDecoder>
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: walletverse_ios_sdk.GDatabase) throws -> Self.RowDecoder?
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.NullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.NullableDatabaseValueCursor<Wrapped>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Wrapped?]
}
extension Swift.Optional where Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.NullableDatabaseValueCursor<Wrapped> where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [Wrapped?] where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk._OptionalProtocol, Self.RowDecoder._Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.NullableDatabaseValueCursor<Self.RowDecoder._Wrapped>
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self.RowDecoder._Wrapped?]
}
extension walletverse_ios_sdk.MutablePersistableRecord where Self : Swift.Encodable {
  public func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Swift.RawRepresentable, Self.RawValue : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
public protocol SQLCollection {
  func collectionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  func contains(_ value: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
}
extension walletverse_ios_sdk.SQLCollection {
  public func contains(_ value: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.SQLExpression
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class IdentityModel : walletverse_ios_sdk.Record, Foundation.NSCoding {
  public var id: Swift.Int64?
  public var wid: Swift.String?
  public var name: Swift.String?
  public var tokenType: Swift.String?
  public var token: Swift.String?
  required public init(row: walletverse_ios_sdk.Row)
  override public func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
  override public func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  override public class var databaseTableName: Swift.String {
    get
  }
  @objc required public init(coder decoder: Foundation.NSCoder)
  @objc public func encode(with coder: Foundation.NSCoder)
  @objc deinit
}
public protocol SQLExpression : walletverse_ios_sdk.SQLOrderingTerm, walletverse_ios_sdk.SQLSelectable, walletverse_ios_sdk.SQLSpecificExpressible {
  func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  var negated: walletverse_ios_sdk.SQLExpression { get }
  func matchedRowIds(rowIdName: Swift.String?) -> Swift.Set<Swift.Int64>?
  func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
extension walletverse_ios_sdk.SQLExpression {
  public var negated: walletverse_ios_sdk.SQLExpression {
    get
  }
  public func matchedRowIds(rowIdName: Swift.String?) -> Swift.Set<Swift.Int64>?
  public func qualifiedSelectable(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLSelectable
  public func qualifiedOrdering(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLOrderingTerm
}
extension walletverse_ios_sdk.SQLExpression {
  public var sqlExpression: walletverse_ios_sdk.SQLExpression {
    get
  }
}
extension walletverse_ios_sdk.SQLExpression {
  public func count(distinct: Swift.Bool) -> walletverse_ios_sdk.SQLCount?
}
@objc @_inheritsConvenienceInitializers public class Constant : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public var Constant_Server: Swift.String
public var Constant_MerchantId: Swift.String
public var Constant_Appid: Swift.String
public var Constant_Appkey: Swift.String
public let Constant_LANGUAGE: Swift.String
public let Constant_CURRENCY: Swift.String
public let Constant_UNIT: Swift.String
public var Constant_UUID: Swift.String
public let Constant_Chars: Swift.String
extension Swift.Bool : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Bool?
}
extension Swift.Int : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Int?
}
extension Swift.Int8 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Int8?
}
extension Swift.Int16 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Int16?
}
extension Swift.Int32 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Int32?
}
extension Swift.Int64 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Int64?
}
extension Swift.UInt : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.UInt?
}
extension Swift.UInt8 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.UInt8?
}
extension Swift.UInt16 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.UInt16?
}
extension Swift.UInt32 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.UInt32?
}
extension Swift.UInt64 : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.UInt64?
}
extension Swift.Double : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Double?
}
extension Swift.Float : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.Float?
}
extension Swift.String : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Swift.String?
}
extension walletverse_ios_sdk.DatabaseFunction {
  public static let capitalize: walletverse_ios_sdk.DatabaseFunction
  public static let lowercase: walletverse_ios_sdk.DatabaseFunction
  public static let uppercase: walletverse_ios_sdk.DatabaseFunction
}
extension walletverse_ios_sdk.DatabaseFunction {
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public static let localizedCapitalize: walletverse_ios_sdk.DatabaseFunction
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public static let localizedLowercase: walletverse_ios_sdk.DatabaseFunction
  @available(iOS 9.0, macOS 10.11, watchOS 3.0, *)
  public static let localizedUppercase: walletverse_ios_sdk.DatabaseFunction
}
extension walletverse_ios_sdk.DatabaseCollation {
  public static let unicodeCompare: walletverse_ios_sdk.DatabaseCollation
  public static let caseInsensitiveCompare: walletverse_ios_sdk.DatabaseCollation
  public static let localizedCaseInsensitiveCompare: walletverse_ios_sdk.DatabaseCollation
  public static let localizedCompare: walletverse_ios_sdk.DatabaseCollation
  public static let localizedStandardCompare: walletverse_ios_sdk.DatabaseCollation
}
extension walletverse_ios_sdk.HTTPMethod {
  public var supportsMultipart: Swift.Bool {
    get
  }
}
extension walletverse_ios_sdk.MoyaProvider {
  public func requestNormal(_ target: Target, callbackQueue: Dispatch.DispatchQueue?, progress: walletverse_ios_sdk.ProgressBlock?, completion: @escaping walletverse_ios_sdk.Completion) -> walletverse_ios_sdk.Cancellable
  public func cancelCompletion(_ completion: (_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>) -> Swift.Void, target: Target)
  final public func createStubFunction(_ token: walletverse_ios_sdk.CancellableToken, forTarget target: Target, withCompletion completion: @escaping walletverse_ios_sdk.Completion, endpoint: walletverse_ios_sdk.Endpoint, plugins: [walletverse_ios_sdk.PluginType], request: Foundation.URLRequest) -> (() -> Swift.Void)
  final public func notifyPluginsOfImpendingStub(for request: Foundation.URLRequest, target: Target)
}
public struct DatabaseMigrator {
  public var eraseDatabaseOnSchemaChange: Swift.Bool
  public init()
  public mutating func registerMigration(_ identifier: Swift.String, migrate: @escaping (walletverse_ios_sdk.GDatabase) throws -> Swift.Void)
  @available(iOS 8.2, macOS 10.10, *)
  public mutating func registerMigrationWithDeferredForeignKeyCheck(_ identifier: Swift.String, migrate: @escaping (walletverse_ios_sdk.GDatabase) throws -> Swift.Void)
  public func migrate(_ writer: walletverse_ios_sdk.DatabaseWriter) throws
  public func migrate(_ writer: walletverse_ios_sdk.DatabaseWriter, upTo targetIdentifier: Swift.String) throws
  public func appliedMigrations(in reader: walletverse_ios_sdk.DatabaseReader) throws -> Swift.Set<Swift.String>
}
extension walletverse_ios_sdk.SQLExpression {
  public var literal: walletverse_ios_sdk.SQLExpressionLiteral {
    get
  }
}
public struct SQLExpressionLiteral : walletverse_ios_sdk.SQLExpression {
  public let sql: Swift.String
  public let arguments: walletverse_ios_sdk.StatementArguments?
  public init(_ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil)
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
public struct SQLUnaryOperator : Swift.Hashable {
  public let sql: Swift.String
  public let needsRightSpace: Swift.Bool
  public init(_ sql: Swift.String, needsRightSpace: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: walletverse_ios_sdk.SQLUnaryOperator, b: walletverse_ios_sdk.SQLUnaryOperator) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionUnary : walletverse_ios_sdk.SQLExpression {
  public let op: walletverse_ios_sdk.SQLUnaryOperator
  public let expression: walletverse_ios_sdk.SQLExpression
  public init(_ op: walletverse_ios_sdk.SQLUnaryOperator, _ value: walletverse_ios_sdk.SQLExpressible)
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
public struct SQLBinaryOperator : Swift.Hashable {
  public let sql: Swift.String
  public let negatedSQL: Swift.String?
  public init(_ sql: Swift.String, negated: Swift.String? = nil)
  public var negated: walletverse_ios_sdk.SQLBinaryOperator? {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: walletverse_ios_sdk.SQLBinaryOperator, b: walletverse_ios_sdk.SQLBinaryOperator) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionBinary : walletverse_ios_sdk.SQLExpression {
  public let lhs: walletverse_ios_sdk.SQLExpression
  public let op: walletverse_ios_sdk.SQLBinaryOperator
  public let rhs: walletverse_ios_sdk.SQLExpression
  public init(_ op: walletverse_ios_sdk.SQLBinaryOperator, _ lhs: walletverse_ios_sdk.SQLExpressible, _ rhs: walletverse_ios_sdk.SQLExpressible)
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public var negated: walletverse_ios_sdk.SQLExpression {
    get
  }
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
public struct SQLFunctionName : Swift.Hashable {
  public var sql: Swift.String
  public init(_ sql: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: walletverse_ios_sdk.SQLFunctionName, b: walletverse_ios_sdk.SQLFunctionName) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct SQLExpressionFunction : walletverse_ios_sdk.SQLExpression {
  public let functionName: walletverse_ios_sdk.SQLFunctionName
  public let arguments: [walletverse_ios_sdk.SQLExpression]
  public init(_ functionName: walletverse_ios_sdk.SQLFunctionName, arguments: [walletverse_ios_sdk.SQLExpression])
  public init(_ functionName: walletverse_ios_sdk.SQLFunctionName, arguments: walletverse_ios_sdk.SQLExpressible...)
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
public enum EndpointSampleResponse {
  case networkResponse(Swift.Int, Foundation.Data)
  case response(Foundation.HTTPURLResponse, Foundation.Data)
  case networkError(Foundation.NSError)
}
open class Endpoint {
  public typealias SampleResponseClosure = () -> walletverse_ios_sdk.EndpointSampleResponse
  final public let url: Swift.String
  final public let sampleResponseClosure: walletverse_ios_sdk.Endpoint.SampleResponseClosure
  final public let method: walletverse_ios_sdk.Method
  final public let task: walletverse_ios_sdk.Task
  final public let httpHeaderFields: [Swift.String : Swift.String]?
  public init(url: Swift.String, sampleResponseClosure: @escaping walletverse_ios_sdk.Endpoint.SampleResponseClosure, method: walletverse_ios_sdk.Method, task: walletverse_ios_sdk.Task, httpHeaderFields: [Swift.String : Swift.String]?)
  open func adding(newHTTPHeaderFields: [Swift.String : Swift.String]) -> walletverse_ios_sdk.Endpoint
  open func replacing(task: walletverse_ios_sdk.Task) -> walletverse_ios_sdk.Endpoint
  @objc deinit
}
extension walletverse_ios_sdk.Endpoint {
  public func urlRequest() throws -> Foundation.URLRequest
}
extension walletverse_ios_sdk.Endpoint : Swift.Equatable, Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: walletverse_ios_sdk.Endpoint, rhs: walletverse_ios_sdk.Endpoint) -> Swift.Bool
  open var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class CommonUtils : ObjectiveC.NSObject {
  public static func stringIsEmpty(value: Swift.AnyObject?) -> Swift.Bool
  public static func specialCharValidate(_ string: Swift.String) -> Swift.Bool
  public static func letterValidate(_ string: Swift.String) -> Swift.Bool
  public static func numberValidate(_ string: Swift.String) -> Swift.Bool
  public static func toolsChangeToJson(info: Any?) -> Swift.String
  public static func getUUID() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
open class URLTransform : walletverse_ios_sdk.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = true)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self.ReferenceType : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Decodable, Self.ReferenceType : walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Foundation.ReferenceConvertible, Self : Swift.Encodable, Self.ReferenceType : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
}
extension Foundation.Data : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Foundation.Data?
}
public protocol ColumnExpression : walletverse_ios_sdk.SQLExpression {
  var name: Swift.String { get }
}
extension walletverse_ios_sdk.ColumnExpression {
  public func expressionSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func qualifiedExpression(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLExpression
  public func resolvedExpression(inContext context: [walletverse_ios_sdk.TableAlias : walletverse_ios_sdk.PersistenceContainer]) -> walletverse_ios_sdk.SQLExpression
}
public struct Column : walletverse_ios_sdk.ColumnExpression {
  public static let rowID: walletverse_ios_sdk.Column
  public var name: Swift.String
  public init(_ name: Swift.String)
}
extension walletverse_ios_sdk.ColumnExpression where Self : Swift.RawRepresentable, Self.RawValue == Swift.String {
  public var name: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.ARequest {
  public enum ValidationResult {
    case success
    case failure(Swift.Error)
  }
}
extension walletverse_ios_sdk.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> walletverse_ios_sdk.ARequest.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping walletverse_ios_sdk.DataRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension walletverse_ios_sdk.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ temporaryURL: Foundation.URL?, _ destinationURL: Foundation.URL?) -> walletverse_ios_sdk.ARequest.ValidationResult
  @discardableResult
  public func validate(_ validation: @escaping walletverse_ios_sdk.DownloadRequest.Validation) -> Self
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
@objc @_hasMissingDesignatedInitializers open class TaskDelegate : ObjectiveC.NSObject {
  final public let queue: Foundation.OperationQueue
  public var data: Foundation.Data? {
    get
  }
  public var error: Swift.Error?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class WalletCoinModel : walletverse_ios_sdk.Record, Foundation.NSCoding {
  public var id: Swift.Int64?
  public var chainId: Swift.String?
  public var symbol: Swift.String?
  public var name: Swift.String?
  public var chainName: Swift.String?
  public var contract: Swift.String?
  public var contractAddress: Swift.String?
  public var iconUrl: Swift.String?
  public var scanUrl: Swift.String?
  public var rpcUrl: Swift.String?
  public var decimals: Swift.String?
  public var type: Swift.String?
  public var vm: Swift.String?
  public var extra: Swift.String?
  public var wid: Swift.String?
  public var address: Swift.String?
  public var privateKey: Swift.String?
  public var balance: Swift.String?
  public var price: Swift.String?
  public var totalPrice: Swift.String?
  public var isAdd: Swift.Bool
  override public func encode(to container: inout walletverse_ios_sdk.PersistenceContainer)
  override public func didInsert(with rowID: Swift.Int64, for column: Swift.String?)
  override public class var databaseTableName: Swift.String {
    get
  }
  @objc required public init(coder decoder: Foundation.NSCoder)
  @objc public func encode(with coder: Foundation.NSCoder)
  public func updateFromCoin(coin: walletverse_ios_sdk.Coin)
  public func updateFromCoinModel(coin: walletverse_ios_sdk.CoinModel)
  @objc deinit
}
public protocol TableRecord {
  static var databaseTableName: Swift.String { get }
  static var databaseSelection: [walletverse_ios_sdk.SQLSelectable] { get }
}
extension walletverse_ios_sdk.TableRecord {
  public static var databaseTableName: Swift.String {
    get
  }
  public static var databaseSelection: [walletverse_ios_sdk.SQLSelectable] {
    get
  }
}
extension walletverse_ios_sdk.TableRecord {
  public static func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.TableRecord {
  public static func selectionSQL(alias: Swift.String? = nil) -> Swift.String
  public static func numberOfSelectedColumns(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.GDatabase {
  @available(*, unavailable, renamed: "inTransaction")
  final public func writeInTransaction(_ kind: walletverse_ios_sdk.GDatabase.TransactionKind? = nil, _ block: (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.GDatabase.TransactionCompletion) throws
}
extension walletverse_ios_sdk.DatabaseValue {
  @available(*, unavailable, message: "DatabaseSequence has been replaced by Cursor.")
  public func value() -> Any
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Swift.Decodable {
  public static func fromDatabaseValue(_ databaseValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.DatabaseValueConvertible where Self : Swift.Decodable, Self : Swift.RawRepresentable, Self.RawValue : walletverse_ios_sdk.DatabaseValueConvertible {
  public static func fromDatabaseValue(_ databaseValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
public typealias SQLiteStatement = Swift.OpaquePointer
@_hasMissingDesignatedInitializers public class Statement {
  final public let sqliteStatement: walletverse_ios_sdk.SQLiteStatement
  public var sql: Swift.String {
    get
  }
  @objc deinit
  public var arguments: walletverse_ios_sdk.StatementArguments {
    get
    set
  }
  public func validate(arguments: walletverse_ios_sdk.StatementArguments) throws
  public func unsafeSetArguments(_ arguments: walletverse_ios_sdk.StatementArguments)
}
@_hasMissingDesignatedInitializers final public class SelectStatement : walletverse_ios_sdk.Statement {
  final public var databaseRegion: walletverse_ios_sdk.DatabaseRegion {
    get
  }
  final public var columnCount: Swift.Int {
    get
  }
  final public var columnNames: [Swift.String] {
    get
    set
  }
  final public func index(ofColumn name: Swift.String) -> Swift.Int?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class StatementCursor : walletverse_ios_sdk.Cursor {
  final public let statement: walletverse_ios_sdk.SelectStatement
  @objc deinit
  final public func next() throws -> Swift.Void?
  public typealias Element = Swift.Void
}
@_hasMissingDesignatedInitializers final public class UpdateStatement : walletverse_ios_sdk.Statement {
  final public func execute(arguments: walletverse_ios_sdk.StatementArguments? = nil) throws
  @objc deinit
}
public struct StatementArguments : Swift.CustomStringConvertible, Swift.Equatable, Swift.ExpressibleByArrayLiteral, Swift.ExpressibleByDictionaryLiteral {
  public var isEmpty: Swift.Bool {
    get
  }
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element == walletverse_ios_sdk.DatabaseValueConvertible?
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  public init?(_ array: [Any])
  public init(_ dictionary: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?])
  public init<Sequence>(_ sequence: Sequence) where Sequence : Swift.Sequence, Sequence.Element == (Swift.String, walletverse_ios_sdk.DatabaseValueConvertible?)
  public init?(_ dictionary: [Swift.AnyHashable : Any])
  public mutating func append(contentsOf arguments: walletverse_ios_sdk.StatementArguments) -> [Swift.String : walletverse_ios_sdk.DatabaseValue]
  public static func + (lhs: walletverse_ios_sdk.StatementArguments, rhs: walletverse_ios_sdk.StatementArguments) -> walletverse_ios_sdk.StatementArguments
  public static func &+ (lhs: walletverse_ios_sdk.StatementArguments, rhs: walletverse_ios_sdk.StatementArguments) -> walletverse_ios_sdk.StatementArguments
  public static func += (lhs: inout walletverse_ios_sdk.StatementArguments, rhs: walletverse_ios_sdk.StatementArguments)
  public static func == (a: walletverse_ios_sdk.StatementArguments, b: walletverse_ios_sdk.StatementArguments) -> Swift.Bool
  public typealias ArrayLiteralElement = walletverse_ios_sdk.DatabaseValueConvertible?
  public typealias Key = Swift.String
  public typealias Value = walletverse_ios_sdk.DatabaseValueConvertible?
}
extension walletverse_ios_sdk.StatementArguments {
  public init(arrayLiteral elements: walletverse_ios_sdk.DatabaseValueConvertible?...)
}
extension walletverse_ios_sdk.StatementArguments {
  public init(dictionaryLiteral elements: (Swift.String, walletverse_ios_sdk.DatabaseValueConvertible?)...)
}
extension walletverse_ios_sdk.StatementArguments {
  public var description: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class Walletverse : ObjectiveC.NSObject {
  public class func shareSingleton() -> walletverse_ios_sdk.Walletverse
  public static func getIdentityModel() -> walletverse_ios_sdk.IdentityModel
  public static func getCoinModel() -> walletverse_ios_sdk.CoinModel
  public static func getWalletCoinModel() -> walletverse_ios_sdk.WalletCoinModel
  public static func install(appId: Swift.String?, appKey: Swift.String?, userConfig: walletverse_ios_sdk.UserConfig?, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func getSDKVersionCode() -> Swift.Int
  public static func getSDKVersionName() -> Swift.String
  public static func changeCurrency(currency: walletverse_ios_sdk.Currency) -> Swift.Bool
  public static func changeLanguage(language: walletverse_ios_sdk.Language) -> Swift.Bool
  public static func changeUnit(unit: walletverse_ios_sdk.Unit) -> Swift.Bool
  public static func validatePassword(password: Swift.String) -> Swift.Bool
  public static func saveWalletCoin(saveCoinParams: walletverse_ios_sdk.SaveCoinParams, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func saveCoinWithMnemonic(coinModel: walletverse_ios_sdk.WalletCoinModel?, contentEn: Swift.String?, walletPin: Swift.String? = "", wid: Swift.String, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func saveCoinWithPrivateKey(coinModel: walletverse_ios_sdk.WalletCoinModel?, contentEn: Swift.String?, walletPin: Swift.String? = "", wid: Swift.String, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func deleteWalletCoin(walletCoinModel: walletverse_ios_sdk.WalletCoinModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func updateWalletCoin(walletCoinModel: walletverse_ios_sdk.WalletCoinModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func queryWalletCoin(walletCoinModel: walletverse_ios_sdk.WalletCoinModel, callback: @escaping (_ result: walletverse_ios_sdk.WalletCoinModel?) -> ())
  public static func queryWalletCoins(walletCoinModel: walletverse_ios_sdk.WalletCoinModel, callback: @escaping (_ result: [walletverse_ios_sdk.WalletCoinModel]?) -> ())
  public static func insertIdentity(identityModel: walletverse_ios_sdk.IdentityModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func deleteIdentity(identityModel: walletverse_ios_sdk.IdentityModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func updateIdentity(identityModel: walletverse_ios_sdk.IdentityModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func queryIdentity(identityModel: walletverse_ios_sdk.IdentityModel, callback: @escaping (_ result: walletverse_ios_sdk.IdentityModel?) -> ())
  public static func queryIdentities(callback: @escaping (_ result: [walletverse_ios_sdk.IdentityModel]?) -> ())
  public static func insertCoin(coinModel: walletverse_ios_sdk.CoinModel, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func queryCoin(coinModel: walletverse_ios_sdk.CoinModel, callback: @escaping (_ result: walletverse_ios_sdk.CoinModel?) -> ())
  public static func queryCoins(coinModel: walletverse_ios_sdk.CoinModel, callback: @escaping (_ result: [walletverse_ios_sdk.CoinModel]?) -> ())
  public static func queryChainCoins(callback: @escaping (_ result: [walletverse_ios_sdk.CoinModel]?) -> ())
  public static func updateConfig(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func toHex(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func generateWid(appId: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func generateWidWithWeb2(params: walletverse_ios_sdk.FederatedParams) -> Swift.String
  public static func generateAccount(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func generateMnemonic(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func getPrivateKey(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func getAddress(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func validateAddress(params: walletverse_ios_sdk.ValidateAddressParams, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func validatePrivateKey(params: walletverse_ios_sdk.ValidatePrivateKeyParams, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func validateMnemonic(params: walletverse_ios_sdk.ValidateMnemonicParams, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func signMessage(params: walletverse_ios_sdk.SignMessageParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func signTransaction(params: walletverse_ios_sdk.SignTransactionParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func signAndTransaction(params: walletverse_ios_sdk.SignAndTransactionParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func transaction(params: walletverse_ios_sdk.TransactionParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func signDAppTransaction(params: walletverse_ios_sdk.SignTransactionParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func toChecksumAddress(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func generateTransferData(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func generateApproveData(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func nonce(params: walletverse_ios_sdk.ChainNonce?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func encodeERC20ABI(params: walletverse_ios_sdk.EncodeERC20ABIParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> ())
  public static func balance(params: walletverse_ios_sdk.CoinBalance?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func decimals(params: walletverse_ios_sdk.CoinDecimals?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func fee(params: walletverse_ios_sdk.CoinFee?, callback: @escaping (_ result: walletverse_ios_sdk.ChainFeeModel?) -> ())
  public static func gasPrice(params: walletverse_ios_sdk.ChainGasPrice?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func blockNumber(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func code(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func receipt(params: Swift.String?, callback: @escaping (_ result: Swift.String?) -> ())
  public static func requestRPC(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> ())
  public static func encodeMessage(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func decodeMessage(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func encodeAuth(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func decodeAuth(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func encodeShard(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func decodeShard(params: walletverse_ios_sdk.JSCoreParams?, callback: @escaping (_ returnData: Any?, _ error: Swift.Error?) -> Swift.Void)
  public static func getSupportChains(params: walletverse_ios_sdk.GetChainsParams, callback: @escaping (_ result: Swift.Array<walletverse_ios_sdk.Coin>?) -> ())
  public static func getTokenList(params: walletverse_ios_sdk.TokenParams, callback: @escaping (_ result: Swift.Array<walletverse_ios_sdk.Coin>?) -> ())
  public static func getToken(params: walletverse_ios_sdk.GetTokenParams, callback: @escaping (_ result: walletverse_ios_sdk.Coin?) -> ())
  public static func getTransactionRecords(params: walletverse_ios_sdk.TransactionRecordParams, callback: @escaping (_ result: Swift.Array<walletverse_ios_sdk.TransactionRecord>?) -> ())
  public static func getPrice(params: walletverse_ios_sdk.GetPriceParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func checkWalletExist(params: walletverse_ios_sdk.FederatedParams) -> Swift.Bool
  public static func signInWeb2(params: walletverse_ios_sdk.FederatedParams, callback: @escaping (_ result: walletverse_ios_sdk.UserprofileModel?) -> ())
  public static func createWeb2Wallet(params: walletverse_ios_sdk.CreateWeb2Params, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func restoreWeb2Wallet(params: walletverse_ios_sdk.RestoreWeb2Params, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func userCrypto(params: walletverse_ios_sdk.RestoreWeb2Params, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func getGraphicsCode(callback: @escaping (_ result: walletverse_ios_sdk.EmailCodeModel?) -> ())
  public static func getEmailCode(params: walletverse_ios_sdk.EmailCodeParams, callback: @escaping (_ result: Swift.Bool) -> ())
  public static func requestEmailVerify(params: walletverse_ios_sdk.EmailVerifyParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func initChain(params: walletverse_ios_sdk.InitChainParams, callback: @escaping (_ result: walletverse_ios_sdk.Coin?) -> ())
  public static func getNftItems(params: walletverse_ios_sdk.NftItemsParams, callback: @escaping (_ result: Swift.Array<walletverse_ios_sdk.NftModel>?) -> ())
  public static func getNftDetail(params: walletverse_ios_sdk.NftDetailParams, callback: @escaping (_ result: walletverse_ios_sdk.NftModel?) -> ())
  public static func getNftTransferData(params: walletverse_ios_sdk.NftTransferDataParams, callback: @escaping (_ result: Swift.String?) -> ())
  public static func getNftTokenURI(params: walletverse_ios_sdk.NftTokenURIParams, callback: @escaping (_ result: Swift.String?) -> ())
  @objc deinit
}
extension walletverse_ios_sdk.ValueObservation where Reducer : walletverse_ios_sdk.ValueReducer, Reducer.Value : Swift.Equatable {
  public func distinctUntilChanged() -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.DistinctUntilChangedValueReducer<Reducer>>
}
extension walletverse_ios_sdk.ValueReducer where Self.Value : Swift.Equatable {
  public func distinctUntilChanged() -> walletverse_ios_sdk.DistinctUntilChangedValueReducer<Self>
}
public struct DistinctUntilChangedValueReducer<Base> : walletverse_ios_sdk.ValueReducer where Base : walletverse_ios_sdk.ValueReducer, Base.Value : Swift.Equatable {
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Base.Fetched
  public mutating func value(_ fetched: Base.Fetched) -> Base.Value?
  public typealias Fetched = Base.Fetched
  public typealias Value = Base.Value
}
public enum AFError : Swift.Error {
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case propertyListEncodingFailed(error: Swift.Error)
  }
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNil
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case propertyListSerializationFailed(error: Swift.Error)
  }
  case invalidURL(url: walletverse_ios_sdk.URLConvertible)
  case parameterEncodingFailed(reason: walletverse_ios_sdk.AFError.ParameterEncodingFailureReason)
  case multipartEncodingFailed(reason: walletverse_ios_sdk.AFError.MultipartEncodingFailureReason)
  case responseValidationFailed(reason: walletverse_ios_sdk.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: walletverse_ios_sdk.AFError.ResponseSerializationFailureReason)
}
extension walletverse_ios_sdk.AFError {
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
}
extension walletverse_ios_sdk.AFError {
  public var urlConvertible: walletverse_ios_sdk.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
}
extension walletverse_ios_sdk.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
open class DataTransform : walletverse_ios_sdk.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
extension Swift.Array {
  public init(reserveCapacity: Swift.Int)
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
}
extension Swift.Array {
  public func split(intoChunksOf chunkSize: Swift.Int) -> [[Element]]
}
public typealias Manager = walletverse_ios_sdk.SessionManager
public typealias Method = walletverse_ios_sdk.HTTPMethod
public typealias RequestMultipartFormData = walletverse_ios_sdk.AMultipartFormData
public typealias MultipartFormDataEncodingResult = walletverse_ios_sdk.Manager.MultipartFormDataEncodingResult
public typealias DownloadDestination = walletverse_ios_sdk.DownloadRequest.DownloadFileDestination
extension walletverse_ios_sdk.ARequest : walletverse_ios_sdk.RequestType {
}
@_hasMissingDesignatedInitializers final public class CancellableToken : walletverse_ios_sdk.Cancellable, Swift.CustomDebugStringConvertible {
  final public var isCancelled: Swift.Bool {
    get
  }
  final public func cancel()
  public init(action: @escaping () -> Swift.Void)
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
public protocol FetchRequest : walletverse_ios_sdk.DatabaseRegionConvertible {
  associatedtype RowDecoder
  func prepare(_ db: walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?)
  func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.FetchRequest {
  public func adapted(_ adapter: @escaping (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.RowAdapter) -> walletverse_ios_sdk.AdaptedFetchRequest<Self>
  public func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
public struct AdaptedFetchRequest<Base> : walletverse_ios_sdk.FetchRequest where Base : walletverse_ios_sdk.FetchRequest {
  public typealias RowDecoder = Base.RowDecoder
  public func prepare(_ db: walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?)
  public func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
public struct AnyFetchRequest<T> : walletverse_ios_sdk.FetchRequest {
  public typealias RowDecoder = T
  public init<Request>(_ request: Request) where Request : walletverse_ios_sdk.FetchRequest
  public init(_ prepare: @escaping (walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?))
  public func prepare(_ db: walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?)
  public func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
public struct SQLRequest<T> : walletverse_ios_sdk.FetchRequest {
  public typealias RowDecoder = T
  public var sql: Swift.String
  public var arguments: walletverse_ios_sdk.StatementArguments?
  public var adapter: walletverse_ios_sdk.RowAdapter?
  public init(_ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil, cached: Swift.Bool = false)
  public init<Request>(_ db: walletverse_ios_sdk.GDatabase, request: Request, cached: Swift.Bool = false) throws where T == Request.RowDecoder, Request : walletverse_ios_sdk.FetchRequest
  public func prepare(_ db: walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?)
}
open class ServerTrustPolicyManager {
  final public let policies: [Swift.String : walletverse_ios_sdk.ServerTrustPolicy]
  public init(policies: [Swift.String : walletverse_ios_sdk.ServerTrustPolicy])
  open func serverTrustPolicy(forHost host: Swift.String) -> walletverse_ios_sdk.ServerTrustPolicy?
  @objc deinit
}
public enum ServerTrustPolicy {
  case performDefaultEvaluation(validateHost: Swift.Bool)
  case performRevokedEvaluation(validateHost: Swift.Bool, revocationFlags: CoreFoundation.CFOptionFlags)
  case pinCertificates(certificates: [Security.SecCertificate], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case pinPublicKeys(publicKeys: [Security.SecKey], validateCertificateChain: Swift.Bool, validateHost: Swift.Bool)
  case disableEvaluation
  case customEvaluation((_ serverTrust: Security.SecTrust, _ host: Swift.String) -> Swift.Bool)
  public static func certificates(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecCertificate]
  public static func publicKeys(in bundle: Foundation.Bundle = Bundle.main) -> [Security.SecKey]
  public func evaluate(_ serverTrust: Security.SecTrust, forHost host: Swift.String) -> Swift.Bool
}
extension Swift.String {
  public func leftPadding(toLength: Swift.Int, withPad character: Swift.Character) -> Swift.String
}
extension walletverse_ios_sdk.ValueObservation where Reducer : walletverse_ios_sdk.ValueReducer {
  public func compactMap<T>(_ transform: @escaping (Reducer.Value) -> T?) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.CompactMapValueReducer<Reducer, T>>
}
extension walletverse_ios_sdk.ValueReducer {
  public func compactMap<T>(_ transform: @escaping (Self.Value) -> T?) -> walletverse_ios_sdk.CompactMapValueReducer<Self, T>
}
public struct CompactMapValueReducer<Base, T> : walletverse_ios_sdk.ValueReducer where Base : walletverse_ios_sdk.ValueReducer {
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> Base.Fetched
  public mutating func value(_ fetched: Base.Fetched) -> T?
  public typealias Fetched = Base.Fetched
  public typealias Value = T
}
public protocol HandyJSONCustomTransformable : walletverse_ios_sdk._ExtendCustomBasicType {
}
public protocol HandyJSON : walletverse_ios_sdk._ExtendCustomModelType {
}
public protocol HandyJSONEnum : walletverse_ios_sdk._RawEnumProtocol {
}
extension walletverse_ios_sdk.GDatabase {
  final public func clearSchemaCache()
  final public func tableExists(_ name: Swift.String) throws -> Swift.Bool
  final public func isSQLiteInternalTable(_ tableName: Swift.String) -> Swift.Bool
  final public func isGRDBInternalTable(_ tableName: Swift.String) -> Swift.Bool
  final public func viewExists(_ name: Swift.String) throws -> Swift.Bool
  final public func triggerExists(_ name: Swift.String) throws -> Swift.Bool
  final public func primaryKey(_ tableName: Swift.String) throws -> walletverse_ios_sdk.PrimaryKeyInfo
  final public func indexes(on tableName: Swift.String) throws -> [walletverse_ios_sdk.IndexInfo]
  final public func table<T>(_ tableName: Swift.String, hasUniqueKey columns: T) throws -> Swift.Bool where T : Swift.Sequence, T.Element == Swift.String
  final public func foreignKeys(on tableName: Swift.String) throws -> [walletverse_ios_sdk.ForeignKeyInfo]
}
extension walletverse_ios_sdk.GDatabase {
  final public func columns(in tableName: Swift.String) throws -> [walletverse_ios_sdk.ColumnInfo]
}
public struct ColumnInfo : walletverse_ios_sdk.FetchableRecord {
  public let name: Swift.String
  public let type: Swift.String
  public let isNotNull: Swift.Bool
  public let defaultValueSQL: Swift.String?
  public let primaryKeyIndex: Swift.Int
  public init(row: walletverse_ios_sdk.Row)
}
public struct IndexInfo {
  public let name: Swift.String
  public let columns: [Swift.String]
  public let isUnique: Swift.Bool
}
public struct PrimaryKeyInfo {
  public var columns: [Swift.String] {
    get
  }
  public var rowIDColumn: Swift.String? {
    get
  }
  public var isRowID: Swift.Bool {
    get
  }
}
public struct ForeignKeyInfo {
  public let destinationTable: Swift.String
  public let mapping: [(origin: Swift.String, destination: Swift.String)]
  public var originColumns: [Swift.String] {
    get
  }
  public var destinationColumns: [Swift.String] {
    get
  }
}
extension Foundation.NSNotification.Name {
  public struct Task {
    public static let DidResume: Foundation.Notification.Name
    public static let DidSuspend: Foundation.Notification.Name
    public static let DidCancel: Foundation.Notification.Name
    public static let DidComplete: Foundation.Notification.Name
  }
}
extension Foundation.Notification {
  public struct Key {
    public static let Task: Swift.String
    public static let ResponseData: Swift.String
  }
}
@available(*, unavailable, renamed: "FetchRequest")
public typealias Request = walletverse_ios_sdk.FetchRequest
@available(*, unavailable, renamed: "FetchableRecord")
public typealias RowConvertible = walletverse_ios_sdk.FetchableRecord
@available(*, unavailable, renamed: "TableRecord")
public typealias TableMapping = walletverse_ios_sdk.TableRecord
@available(*, unavailable, renamed: "MutablePersistableRecord")
public typealias MutablePersistable = walletverse_ios_sdk.MutablePersistableRecord
@available(*, unavailable, renamed: "PersistableRecord")
public typealias Persistable = walletverse_ios_sdk.PersistableRecord
@available(*, unavailable, renamed: "TableAlias")
public typealias SQLTableQualifier = walletverse_ios_sdk.TableAlias
extension walletverse_ios_sdk.GDatabase {
  @available(*, unavailable, message: "Use db.columns(in: tableName).count instead")
  final public func columnCount(in tableName: Swift.String) throws -> Swift.Int
}
extension walletverse_ios_sdk.SelectStatement {
  @available(*, unavailable, renamed: "DatabaseRegion")
  public typealias SelectionInfo = walletverse_ios_sdk.DatabaseRegion
  @available(*, unavailable, renamed: "databaseRegion")
  final public var selectionInfo: walletverse_ios_sdk.DatabaseRegion {
    get
  }
  @available(*, unavailable, renamed: "databaseRegion")
  final public var fetchedRegion: walletverse_ios_sdk.DatabaseRegion {
    get
  }
}
extension walletverse_ios_sdk.DatabaseEventKind {
  @available(*, unavailable, message: "Use DatabaseRegion.isModified(byEventsOfKind:) instead")
  public func impacts(_ region: walletverse_ios_sdk.DatabaseRegion) -> Swift.Bool
}
extension walletverse_ios_sdk.Record {
  @available(*, unavailable, renamed: "hasDatabaseChanges")
  public var hasPersistentChangedValues: Swift.Bool {
    get
  }
  @available(*, unavailable, renamed: "databaseChanges")
  public var persistentChangedValues: [Swift.String : walletverse_ios_sdk.DatabaseValue?] {
    get
  }
}
@_inheritsConvenienceInitializers @available(*, unavailable, message: "Use changes methods defined on the MutablePersistableRecord protocol: databaseEquals(_:), databaseChanges(from:), updateChanges(from:)")
final public class RecordBox<T> : walletverse_ios_sdk.Record where T : walletverse_ios_sdk.FetchableRecord, T : walletverse_ios_sdk.MutablePersistableRecord {
  override public init()
  required public init(row: walletverse_ios_sdk.Row)
  @objc deinit
}
extension walletverse_ios_sdk.MutablePersistableRecord {
  @available(*, unavailable, renamed: "databaseEquals")
  public func databaseEqual(_ record: Self) -> Swift.Bool
}
extension walletverse_ios_sdk.Row {
  @available(*, unavailable, message: "Use row.scopes[name] instead")
  final public func scoped(on name: Swift.String) -> walletverse_ios_sdk.Row?
}
extension walletverse_ios_sdk.FetchRequest {
  @available(*, unavailable, renamed: "databaseRegion(_:)")
  public func fetchedRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
extension walletverse_ios_sdk.DatabaseError {
  @available(*, unavailable, renamed: "resultCode")
  public var code: Swift.Int32 {
    get
  }
}
public protocol SQLOrderingTerm {
  var reversed: walletverse_ios_sdk.SQLOrderingTerm { get }
  func orderingTermSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  func qualifiedOrdering(with alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.SQLOrderingTerm
}
public typealias CustomMappingKeyValueTuple = (Swift.Int, walletverse_ios_sdk.MappingPropertyHandler)
public class MappingPropertyHandler {
  public init(rawPaths: [Swift.String]?, assignmentClosure: ((Any?) -> (Any?))?, takeValueClosure: ((Any?) -> (Any?))?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class HelpingMapper {
  public func specify<T>(property: inout T, name: Swift.String)
  public func specify<T>(property: inout T, converter: @escaping (Swift.String) -> T)
  public func specify<T>(property: inout T, name: Swift.String?, converter: ((Swift.String) -> T)?)
  public func exclude<T>(property: inout T)
  @objc deinit
}
infix operator <-- : LogicalConjunctionPrecedence
public func <-- <T>(property: inout T, name: Swift.String) -> walletverse_ios_sdk.CustomMappingKeyValueTuple
public func <-- <T>(property: inout T, names: [Swift.String]) -> walletverse_ios_sdk.CustomMappingKeyValueTuple
public func <-- <Transform>(property: inout Transform.Object, transformer: Transform) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
public func <-- <Transform>(property: inout Transform.Object, transformer: (Swift.String?, Transform?)) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
public func <-- <Transform>(property: inout Transform.Object, transformer: ([Swift.String], Transform?)) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: Transform) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: (Swift.String?, Transform?)) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
public func <-- <Transform>(property: inout Transform.Object?, transformer: ([Swift.String], Transform?)) -> walletverse_ios_sdk.CustomMappingKeyValueTuple where Transform : walletverse_ios_sdk.TransformType
infix operator <<< : AssignmentPrecedence
public func <<< (mapper: walletverse_ios_sdk.HelpingMapper, mapping: walletverse_ios_sdk.CustomMappingKeyValueTuple)
public func <<< (mapper: walletverse_ios_sdk.HelpingMapper, mappings: [walletverse_ios_sdk.CustomMappingKeyValueTuple])
infix operator >>> : AssignmentPrecedence
public func >>> <T>(mapper: walletverse_ios_sdk.HelpingMapper, property: inout T)
public protocol Association : walletverse_ios_sdk.DerivableRequest {
  associatedtype OriginRowDecoder
  associatedtype RowDecoder
  associatedtype Impl : walletverse_ios_sdk.AssociationImpl
  var _impl: Self.Impl { get }
  init(_impl: Self.Impl)
}
extension walletverse_ios_sdk.Association {
  public func select(_ selection: [walletverse_ios_sdk.SQLSelectable]) -> Self
  public func filter(_ predicate: @escaping (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.SQLExpressible) -> Self
  public func order(_ orderings: @escaping (walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.SQLOrderingTerm]) -> Self
  public func reversed() -> Self
  public func forKey(_ key: Swift.String) -> Self
  public func forKey(_ codingKey: Swift.CodingKey) -> Self
  public func aliased(_ alias: walletverse_ios_sdk.TableAlias) -> Self
}
extension walletverse_ios_sdk.Association {
  public func including<A>(optional association: A) -> Self where A : walletverse_ios_sdk.Association, Self.RowDecoder == A.OriginRowDecoder
  public func including<A>(required association: A) -> Self where A : walletverse_ios_sdk.Association, Self.RowDecoder == A.OriginRowDecoder
  public func joining<A>(optional association: A) -> Self where A : walletverse_ios_sdk.Association, Self.RowDecoder == A.OriginRowDecoder
  public func joining<A>(required association: A) -> Self where A : walletverse_ios_sdk.Association, Self.RowDecoder == A.OriginRowDecoder
}
public protocol AssociationImpl {
  var key: Swift.String { get }
  func forKey(_ key: Swift.String) -> Self
  func mapRelation(_ transform: (walletverse_ios_sdk.SQLRelation) -> walletverse_ios_sdk.SQLRelation) -> Self
  func joinedRelation(_ relation: walletverse_ios_sdk.SQLRelation, joinOperator: walletverse_ios_sdk.JoinOperator) -> walletverse_ios_sdk.SQLRelation
  var relation: walletverse_ios_sdk.SQLRelation { get }
  var joinCondition: walletverse_ios_sdk.JoinCondition { get }
}
public struct JoinAssociationImpl : walletverse_ios_sdk.AssociationImpl {
  public var key: Swift.String
  public let joinCondition: walletverse_ios_sdk.JoinCondition
  public var relation: walletverse_ios_sdk.SQLRelation
  public func forKey(_ key: Swift.String) -> walletverse_ios_sdk.JoinAssociationImpl
  public func mapRelation(_ transform: (walletverse_ios_sdk.SQLRelation) -> walletverse_ios_sdk.SQLRelation) -> walletverse_ios_sdk.JoinAssociationImpl
  public func joinedRelation(_ relation: walletverse_ios_sdk.SQLRelation, joinOperator: walletverse_ios_sdk.JoinOperator) -> walletverse_ios_sdk.SQLRelation
}
extension walletverse_ios_sdk.GDatabase {
  @available(iOS 8.2, macOS 10.10, *)
  final public func create(table name: Swift.String, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, withoutRowID: Swift.Bool, body: (walletverse_ios_sdk.TableDefinition) -> Swift.Void) throws
  final public func create(table name: Swift.String, temporary: Swift.Bool = false, ifNotExists: Swift.Bool = false, body: (walletverse_ios_sdk.TableDefinition) -> Swift.Void) throws
  final public func rename(table name: Swift.String, to newName: Swift.String) throws
  final public func alter(table name: Swift.String, body: (walletverse_ios_sdk.TableAlteration) -> Swift.Void) throws
  final public func drop(table name: Swift.String) throws
  final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false) throws
  @available(iOS 8.2, macOS 10.10, *)
  final public func create(index name: Swift.String, on table: Swift.String, columns: [Swift.String], unique: Swift.Bool = false, ifNotExists: Swift.Bool = false, condition: walletverse_ios_sdk.SQLExpressible) throws
  final public func drop(index name: Swift.String) throws
  final public func reindex(collation: walletverse_ios_sdk.GDatabase.CollationName) throws
  final public func reindex(collation: walletverse_ios_sdk.DatabaseCollation) throws
}
@_hasMissingDesignatedInitializers final public class TableDefinition {
  @discardableResult
  final public func autoIncrementedPrimaryKey(_ name: Swift.String, onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil) -> walletverse_ios_sdk.ColumnDefinition
  @discardableResult
  final public func column(_ name: Swift.String, _ type: walletverse_ios_sdk.GDatabase.ColumnType? = nil) -> walletverse_ios_sdk.ColumnDefinition
  final public func primaryKey(_ columns: [Swift.String], onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil)
  final public func uniqueKey(_ columns: [Swift.String], onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil)
  final public func foreignKey(_ columns: [Swift.String], references table: Swift.String, columns destinationColumns: [Swift.String]? = nil, onDelete deleteAction: walletverse_ios_sdk.GDatabase.ForeignKeyAction? = nil, onUpdate updateAction: walletverse_ios_sdk.GDatabase.ForeignKeyAction? = nil, deferred: Swift.Bool = false)
  final public func check(_ condition: walletverse_ios_sdk.SQLExpressible)
  final public func check(sql: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class TableAlteration {
  @discardableResult
  final public func add(column name: Swift.String, _ type: walletverse_ios_sdk.GDatabase.ColumnType? = nil) -> walletverse_ios_sdk.ColumnDefinition
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class ColumnDefinition {
  @discardableResult
  final public func primaryKey(onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil, autoincrement: Swift.Bool = false) -> Self
  @discardableResult
  final public func notNull(onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func unique(onConflict conflictResolution: walletverse_ios_sdk.GDatabase.ConflictResolution? = nil) -> Self
  @discardableResult
  final public func indexed() -> Self
  @discardableResult
  final public func check(_ condition: (walletverse_ios_sdk.Column) -> walletverse_ios_sdk.SQLExpressible) -> Self
  @discardableResult
  final public func check(sql: Swift.String) -> Self
  @discardableResult
  final public func defaults(to value: walletverse_ios_sdk.DatabaseValueConvertible) -> Self
  @discardableResult
  final public func defaults(sql: Swift.String) -> Self
  @discardableResult
  final public func collate(_ collation: walletverse_ios_sdk.GDatabase.CollationName) -> Self
  @discardableResult
  final public func collate(_ collation: walletverse_ios_sdk.DatabaseCollation) -> Self
  @discardableResult
  final public func references(_ table: Swift.String, column: Swift.String? = nil, onDelete deleteAction: walletverse_ios_sdk.GDatabase.ForeignKeyAction? = nil, onUpdate updateAction: walletverse_ios_sdk.GDatabase.ForeignKeyAction? = nil, deferred: Swift.Bool = false) -> Self
  @objc deinit
}
public struct DatabaseRegion : Swift.CustomStringConvertible, Swift.Equatable {
  public var isEmpty: Swift.Bool {
    get
  }
  public static let fullDatabase: walletverse_ios_sdk.DatabaseRegion
  public init()
  public func union(_ other: walletverse_ios_sdk.DatabaseRegion) -> walletverse_ios_sdk.DatabaseRegion
  public mutating func formUnion(_ other: walletverse_ios_sdk.DatabaseRegion)
}
extension walletverse_ios_sdk.DatabaseRegion {
  public func isModified(byEventsOfKind eventKind: walletverse_ios_sdk.DatabaseEventKind) -> Swift.Bool
  public func isModified(by event: walletverse_ios_sdk.DatabaseEvent) -> Swift.Bool
}
extension walletverse_ios_sdk.DatabaseRegion {
  public static func == (lhs: walletverse_ios_sdk.DatabaseRegion, rhs: walletverse_ios_sdk.DatabaseRegion) -> Swift.Bool
}
extension walletverse_ios_sdk.DatabaseRegion {
  public var description: Swift.String {
    get
  }
}
public protocol DatabaseRegionConvertible {
  func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
extension walletverse_ios_sdk.DatabaseRegion : walletverse_ios_sdk.DatabaseRegionConvertible {
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
public struct AnyDatabaseRegionConvertible : walletverse_ios_sdk.DatabaseRegionConvertible {
  public init(_ region: @escaping (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion)
  public init(_ region: walletverse_ios_sdk.DatabaseRegionConvertible)
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
public struct ResultCode : Swift.RawRepresentable, Swift.Equatable, Swift.CustomStringConvertible {
  public let rawValue: Swift.Int32
  public init(rawValue: Swift.Int32)
  public var primaryResultCode: walletverse_ios_sdk.ResultCode {
    get
  }
  public static func ~= (pattern: walletverse_ios_sdk.ResultCode, code: walletverse_ios_sdk.ResultCode) -> Swift.Bool
  public static let SQLITE_OK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_ERROR: walletverse_ios_sdk.ResultCode
  public static let SQLITE_INTERNAL: walletverse_ios_sdk.ResultCode
  public static let SQLITE_PERM: walletverse_ios_sdk.ResultCode
  public static let SQLITE_ABORT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_BUSY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_LOCKED: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOMEM: walletverse_ios_sdk.ResultCode
  public static let SQLITE_READONLY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_INTERRUPT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CORRUPT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOTFOUND: walletverse_ios_sdk.ResultCode
  public static let SQLITE_FULL: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CANTOPEN: walletverse_ios_sdk.ResultCode
  public static let SQLITE_PROTOCOL: walletverse_ios_sdk.ResultCode
  public static let SQLITE_EMPTY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_SCHEMA: walletverse_ios_sdk.ResultCode
  public static let SQLITE_TOOBIG: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_MISMATCH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_MISUSE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOLFS: walletverse_ios_sdk.ResultCode
  public static let SQLITE_AUTH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_FORMAT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_RANGE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOTADB: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOTICE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_WARNING: walletverse_ios_sdk.ResultCode
  public static let SQLITE_ROW: walletverse_ios_sdk.ResultCode
  public static let SQLITE_DONE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_READ: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SHORT_READ: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_WRITE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_FSYNC: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_DIR_FSYNC: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_TRUNCATE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_FSTAT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_UNLOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_RDLOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_DELETE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_BLOCKED: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_NOMEM: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_ACCESS: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_CHECKRESERVEDLOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_LOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_CLOSE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_DIR_CLOSE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SHMOPEN: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SHMSIZE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SHMLOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SHMMAP: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_SEEK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_DELETE_NOENT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_MMAP: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_GETTEMPPATH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_CONVPATH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_VNODE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_IOERR_AUTH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_LOCKED_SHAREDCACHE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_BUSY_RECOVERY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_BUSY_SNAPSHOT: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CANTOPEN_NOTEMPDIR: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CANTOPEN_ISDIR: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CANTOPEN_FULLPATH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CANTOPEN_CONVPATH: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CORRUPT_VTAB: walletverse_ios_sdk.ResultCode
  public static let SQLITE_READONLY_RECOVERY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_READONLY_CANTLOCK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_READONLY_ROLLBACK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_READONLY_DBMOVED: walletverse_ios_sdk.ResultCode
  public static let SQLITE_ABORT_ROLLBACK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_CHECK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_COMMITHOOK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_FOREIGNKEY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_FUNCTION: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_NOTNULL: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_PRIMARYKEY: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_TRIGGER: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_UNIQUE: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_VTAB: walletverse_ios_sdk.ResultCode
  public static let SQLITE_CONSTRAINT_ROWID: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOTICE_RECOVER_WAL: walletverse_ios_sdk.ResultCode
  public static let SQLITE_NOTICE_RECOVER_ROLLBACK: walletverse_ios_sdk.ResultCode
  public static let SQLITE_WARNING_AUTOINDEX: walletverse_ios_sdk.ResultCode
  public static let SQLITE_AUTH_USER: walletverse_ios_sdk.ResultCode
  public static let SQLITE_OK_LOAD_PERMANENTLY: walletverse_ios_sdk.ResultCode
  public typealias RawValue = Swift.Int32
}
extension walletverse_ios_sdk.ResultCode {
  public var description: Swift.String {
    get
  }
}
public struct DatabaseError : Swift.Error, Swift.CustomStringConvertible, Foundation.CustomNSError {
  public var resultCode: walletverse_ios_sdk.ResultCode {
    get
  }
  public let extendedResultCode: walletverse_ios_sdk.ResultCode
  public let message: Swift.String?
  public let sql: Swift.String?
  public init(resultCode: walletverse_ios_sdk.ResultCode = .SQLITE_ERROR, message: Swift.String? = nil, sql: Swift.String? = nil, arguments: walletverse_ios_sdk.StatementArguments? = nil)
}
extension walletverse_ios_sdk.DatabaseError {
  public var description: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.DatabaseError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public protocol VirtualTableModule {
  associatedtype TableDefinition
  var moduleName: Swift.String { get }
  func makeTableDefinition() -> Self.TableDefinition
  func moduleArguments(for definition: Self.TableDefinition, in db: walletverse_ios_sdk.GDatabase) throws -> [Swift.String]
  func database(_ db: walletverse_ios_sdk.GDatabase, didCreate tableName: Swift.String, using definition: Self.TableDefinition) throws
}
extension walletverse_ios_sdk.GDatabase {
  final public func create(virtualTable name: Swift.String, ifNotExists: Swift.Bool = false, using module: Swift.String) throws
  final public func create<Module>(virtualTable tableName: Swift.String, ifNotExists: Swift.Bool = false, using module: Module, _ body: ((Module.TableDefinition) -> Swift.Void)? = nil) throws where Module : walletverse_ios_sdk.VirtualTableModule
}
@_hasMissingDesignatedInitializers final public class Row : Swift.Equatable, Swift.Hashable, Swift.RandomAccessCollection, Swift.ExpressibleByDictionaryLiteral, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public let count: Swift.Int
  convenience public init()
  convenience public init(_ dictionary: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?])
  convenience public init?(_ dictionary: [Swift.AnyHashable : Any])
  final public func copy() -> walletverse_ios_sdk.Row
  @objc deinit
  public typealias Element = (Swift.String, walletverse_ios_sdk.DatabaseValue)
  public typealias Index = walletverse_ios_sdk.RowIndex
  public typealias Indices = Swift.Range<walletverse_ios_sdk.RowIndex>
  public typealias Iterator = Swift.IndexingIterator<walletverse_ios_sdk.Row>
  public typealias Key = Swift.String
  public typealias SubSequence = Swift.Slice<walletverse_ios_sdk.Row>
  public typealias Value = walletverse_ios_sdk.DatabaseValueConvertible?
  final public var hashValue: Swift.Int {
    get
  }
}
extension walletverse_ios_sdk.Row {
  final public var columnNames: Swift.LazyMapCollection<walletverse_ios_sdk.Row, Swift.String> {
    get
  }
  final public func hasColumn(_ columnName: Swift.String) -> Swift.Bool
}
extension walletverse_ios_sdk.Row {
  final public var containsNonNullValue: Swift.Bool {
    get
  }
  final public func hasNull(atIndex index: Swift.Int) -> Swift.Bool
  final public subscript(index: Swift.Int) -> walletverse_ios_sdk.DatabaseValueConvertible? {
    get
  }
  final public subscript<Value>(index: Swift.Int) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(index: Swift.Int) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public subscript<Value>(index: Swift.Int) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(index: Swift.Int) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public subscript(columnName: Swift.String) -> walletverse_ios_sdk.DatabaseValueConvertible? {
    get
  }
  final public subscript<Value>(columnName: Swift.String) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(columnName: Swift.String) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public subscript<Value>(columnName: Swift.String) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(columnName: Swift.String) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public subscript(column: walletverse_ios_sdk.ColumnExpression) -> walletverse_ios_sdk.DatabaseValueConvertible? {
    get
  }
  final public subscript<Value>(column: walletverse_ios_sdk.ColumnExpression) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(column: walletverse_ios_sdk.ColumnExpression) -> Value? where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public subscript<Value>(column: walletverse_ios_sdk.ColumnExpression) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible {
    get
  }
  final public subscript<Value>(column: walletverse_ios_sdk.ColumnExpression) -> Value where Value : walletverse_ios_sdk.DatabaseValueConvertible, Value : walletverse_ios_sdk.StatementColumnConvertible {
    get
  }
  final public func dataNoCopy(atIndex index: Swift.Int) -> Foundation.Data?
  final public func dataNoCopy(named columnName: Swift.String) -> Foundation.Data?
  final public func dataNoCopy(_ column: walletverse_ios_sdk.ColumnExpression) -> Foundation.Data?
}
extension walletverse_ios_sdk.Row {
  final public var databaseValues: Swift.LazyMapCollection<walletverse_ios_sdk.Row, walletverse_ios_sdk.DatabaseValue> {
    get
  }
}
extension walletverse_ios_sdk.Row {
  final public subscript<Record>(scope: Swift.String) -> Record where Record : walletverse_ios_sdk.FetchableRecord {
    get
  }
  final public subscript<Record>(scope: Swift.String) -> Record? where Record : walletverse_ios_sdk.FetchableRecord {
    get
  }
}
extension walletverse_ios_sdk.Row {
  final public var scopes: walletverse_ios_sdk.Row.ScopesView {
    get
  }
  final public var scopesTree: walletverse_ios_sdk.Row.ScopesTreeView {
    get
  }
  final public var unscoped: walletverse_ios_sdk.Row {
    get
  }
  final public var unadapted: walletverse_ios_sdk.Row {
    get
  }
}
@_hasMissingDesignatedInitializers final public class RowCursor : walletverse_ios_sdk.Cursor {
  final public let statement: walletverse_ios_sdk.SelectStatement
  @objc deinit
  final public func next() throws -> walletverse_ios_sdk.Row?
  public typealias Element = walletverse_ios_sdk.Row
}
extension walletverse_ios_sdk.Row {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.RowCursor
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [walletverse_ios_sdk.Row]
  public static func fetchOne(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.Row?
}
extension walletverse_ios_sdk.Row {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.RowCursor
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [walletverse_ios_sdk.Row]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.Row?
}
extension walletverse_ios_sdk.Row {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.RowCursor where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [walletverse_ios_sdk.Row] where R : walletverse_ios_sdk.FetchRequest
  public static func fetchOne<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.Row? where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk.Row {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.RowCursor
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.Row]
  public func fetchOne(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.Row?
}
extension walletverse_ios_sdk.Row {
  convenience public init(dictionaryLiteral elements: (Swift.String, walletverse_ios_sdk.DatabaseValueConvertible?)...)
}
extension walletverse_ios_sdk.Row {
  final public var startIndex: walletverse_ios_sdk.RowIndex {
    get
  }
  final public var endIndex: walletverse_ios_sdk.RowIndex {
    get
  }
  final public subscript(position: walletverse_ios_sdk.RowIndex) -> (Swift.String, walletverse_ios_sdk.DatabaseValue) {
    get
  }
}
extension walletverse_ios_sdk.Row {
  public static func == (lhs: walletverse_ios_sdk.Row, rhs: walletverse_ios_sdk.Row) -> Swift.Bool
}
extension walletverse_ios_sdk.Row {
  final public func hash(into hasher: inout Swift.Hasher)
}
extension walletverse_ios_sdk.Row {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
public struct RowIndex : Swift.Comparable, Swift.Strideable {
  public typealias Stride = Swift.Int
}
extension walletverse_ios_sdk.RowIndex {
  public static func == (lhs: walletverse_ios_sdk.RowIndex, rhs: walletverse_ios_sdk.RowIndex) -> Swift.Bool
  public static func < (lhs: walletverse_ios_sdk.RowIndex, rhs: walletverse_ios_sdk.RowIndex) -> Swift.Bool
}
extension walletverse_ios_sdk.RowIndex {
  public func distance(to other: walletverse_ios_sdk.RowIndex) -> Swift.Int
  public func advanced(by n: Swift.Int) -> walletverse_ios_sdk.RowIndex
}
extension walletverse_ios_sdk.Row {
  public struct ScopesView : Swift.Collection {
    public typealias Index = Swift.Dictionary<Swift.String, walletverse_ios_sdk.LayoutedRowAdapter>.Index
    public var names: Swift.Dictionary<Swift.String, walletverse_ios_sdk.LayoutedRowAdapter>.Keys {
      get
    }
    public var startIndex: walletverse_ios_sdk.Row.ScopesView.Index {
      get
    }
    public var endIndex: walletverse_ios_sdk.Row.ScopesView.Index {
      get
    }
    public func index(after i: walletverse_ios_sdk.Row.ScopesView.Index) -> walletverse_ios_sdk.Row.ScopesView.Index
    public subscript(position: walletverse_ios_sdk.Row.ScopesView.Index) -> (name: Swift.String, row: walletverse_ios_sdk.Row) {
      get
    }
    public subscript(name: Swift.String) -> walletverse_ios_sdk.Row? {
      get
    }
    public typealias Element = (name: Swift.String, row: walletverse_ios_sdk.Row)
    public typealias Indices = Swift.DefaultIndices<walletverse_ios_sdk.Row.ScopesView>
    public typealias Iterator = Swift.IndexingIterator<walletverse_ios_sdk.Row.ScopesView>
    public typealias SubSequence = Swift.Slice<walletverse_ios_sdk.Row.ScopesView>
  }
}
extension walletverse_ios_sdk.Row {
  public struct ScopesTreeView {
    public var names: Swift.Set<Swift.String> {
      get
    }
    public subscript(name: Swift.String) -> walletverse_ios_sdk.Row? {
      get
    }
  }
}
extension Foundation.NSURL : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension Foundation.URL : walletverse_ios_sdk.DatabaseValueConvertible {
}
public protocol AccessTokenAuthorizable {
  var authorizationType: walletverse_ios_sdk.AuthorizationType { get }
}
public enum AuthorizationType {
  case none
  case basic
  case bearer
  case custom(Swift.String)
  public var value: Swift.String? {
    get
  }
}
public struct AccessTokenPlugin : walletverse_ios_sdk.PluginType {
  public let tokenClosure: () -> Swift.String
  public init(tokenClosure: @escaping () -> Swift.String)
  public func prepare(_ request: Foundation.URLRequest, target: walletverse_ios_sdk.TargetType) -> Foundation.URLRequest
}
@_hasMissingDesignatedInitializers final public class FetchedRecordsController<Record> where Record : walletverse_ios_sdk.FetchableRecord {
  convenience public init(_ databaseWriter: walletverse_ios_sdk.DatabaseWriter, sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil, queue: Dispatch.DispatchQueue = .main, isSameRecord: ((Record, Record) -> Swift.Bool)? = nil) throws
  convenience public init<Request>(_ databaseWriter: walletverse_ios_sdk.DatabaseWriter, request: Request, queue: Dispatch.DispatchQueue = .main, isSameRecord: ((Record, Record) -> Swift.Bool)? = nil) throws where Record == Request.RowDecoder, Request : walletverse_ios_sdk.FetchRequest
  final public func performFetch() throws
  final public let databaseWriter: walletverse_ios_sdk.DatabaseWriter
  final public let queue: Dispatch.DispatchQueue
  final public func setRequest<Request>(_ request: Request) throws where Record == Request.RowDecoder, Request : walletverse_ios_sdk.FetchRequest
  final public func setRequest(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws
  final public func trackChanges(willChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>) -> ())? = nil, onChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>, Record, walletverse_ios_sdk.FetchedRecordChange) -> ())? = nil, didChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>) -> ())? = nil)
  final public func trackChanges<T>(fetchAlongside: @escaping (walletverse_ios_sdk.GDatabase) throws -> T, willChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>, _ fetchedAlongside: T) -> ())? = nil, onChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>, Record, walletverse_ios_sdk.FetchedRecordChange) -> ())? = nil, didChange: ((walletverse_ios_sdk.FetchedRecordsController<Record>, _ fetchedAlongside: T) -> ())? = nil)
  final public func trackErrors(_ errorHandler: @escaping (walletverse_ios_sdk.FetchedRecordsController<Record>, Swift.Error) -> ())
  final public func allowBackgroundChangesTracking(in application: UIKit.UIApplication)
  final public var fetchedRecords: [Record] {
    get
  }
  @objc deinit
}
extension walletverse_ios_sdk.FetchedRecordsController where Record : walletverse_ios_sdk.TableRecord {
  convenience public init(_ databaseWriter: walletverse_ios_sdk.DatabaseWriter, sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil, queue: Dispatch.DispatchQueue = .main) throws
  convenience public init<Request>(_ databaseWriter: walletverse_ios_sdk.DatabaseWriter, request: Request, queue: Dispatch.DispatchQueue = .main) throws where Record == Request.RowDecoder, Request : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchedRecordsController {
  final public func record(at indexPath: Foundation.IndexPath) -> Record
  final public var sections: [walletverse_ios_sdk.FetchedRecordsSectionInfo<Record>] {
    get
  }
}
extension walletverse_ios_sdk.FetchedRecordsController where Record : walletverse_ios_sdk.MutablePersistableRecord {
  final public func indexPath(for record: Record) -> Foundation.IndexPath?
}
public enum FetchedRecordChange {
  case insertion(indexPath: Foundation.IndexPath)
  case deletion(indexPath: Foundation.IndexPath)
  case move(indexPath: Foundation.IndexPath, newIndexPath: Foundation.IndexPath, changes: [Swift.String : walletverse_ios_sdk.DatabaseValue])
  case update(indexPath: Foundation.IndexPath, changes: [Swift.String : walletverse_ios_sdk.DatabaseValue])
}
extension walletverse_ios_sdk.FetchedRecordChange : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct FetchedRecordsSectionInfo<Record> where Record : walletverse_ios_sdk.FetchableRecord {
  public var numberOfRecords: Swift.Int {
    get
  }
  public var records: [Record] {
    get
  }
}
public enum Currency : Swift.String {
  case CNY
  case USD
  case KRW
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Language : Swift.String {
  case ZH
  case EN
  case KO
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Unit : Swift.String {
  case USDT
  case USD
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Condition : Swift.String {
  case ALL
  case OUT
  case IN
  case FAIL
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum Channel : Swift.String {
  case Google
  case Twitter
  case FaceBook
  case GitHub
  case Discord
  case Line
  case KaKao
  case Email
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias SQLiteConnection = Swift.OpaquePointer
@_hasMissingDesignatedInitializers final public class GDatabase {
  final public let sqliteConnection: walletverse_ios_sdk.SQLiteConnection
  public static var logError: walletverse_ios_sdk.GDatabase.LogErrorFunction? {
    get
    set
  }
  final public let configuration: walletverse_ios_sdk.GConfiguration
  final public var lastInsertedRowID: Swift.Int64 {
    get
  }
  final public var changesCount: Swift.Int {
    get
  }
  final public var totalChangesCount: Swift.Int {
    get
  }
  final public var isInsideTransaction: Swift.Bool {
    get
  }
  @objc deinit
}
extension walletverse_ios_sdk.GDatabase {
  final public func add(function: walletverse_ios_sdk.DatabaseFunction)
  final public func remove(function: walletverse_ios_sdk.DatabaseFunction)
}
extension walletverse_ios_sdk.GDatabase {
  final public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
}
extension walletverse_ios_sdk.GDatabase {
  final public func inTransaction(_ kind: walletverse_ios_sdk.GDatabase.TransactionKind? = nil, _ block: () throws -> walletverse_ios_sdk.GDatabase.TransactionCompletion) throws
  final public func inSavepoint(_ block: () throws -> walletverse_ios_sdk.GDatabase.TransactionCompletion) throws
  final public func beginTransaction(_ kind: walletverse_ios_sdk.GDatabase.TransactionKind? = nil) throws
  final public func rollback() throws
  final public func commit() throws
}
extension walletverse_ios_sdk.GDatabase {
  public typealias BusyCallback = (_ numberOfTries: Swift.Int) -> Swift.Bool
  public enum BusyMode {
    case immediateError
    case timeout(Foundation.TimeInterval)
    case callback(walletverse_ios_sdk.GDatabase.BusyCallback)
  }
  public enum CheckpointMode : Swift.Int32 {
    case passive
    case full
    case restart
    case truncate
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public struct CollationName : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(_ rawValue: Swift.String)
    public static let binary: walletverse_ios_sdk.GDatabase.CollationName
    public static let nocase: walletverse_ios_sdk.GDatabase.CollationName
    public static let rtrim: walletverse_ios_sdk.GDatabase.CollationName
    public typealias RawValue = Swift.String
  }
  public struct ColumnType : Swift.RawRepresentable, Swift.Hashable {
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public init(_ rawValue: Swift.String)
    public static let text: walletverse_ios_sdk.GDatabase.ColumnType
    public static let integer: walletverse_ios_sdk.GDatabase.ColumnType
    public static let double: walletverse_ios_sdk.GDatabase.ColumnType
    public static let numeric: walletverse_ios_sdk.GDatabase.ColumnType
    public static let boolean: walletverse_ios_sdk.GDatabase.ColumnType
    public static let blob: walletverse_ios_sdk.GDatabase.ColumnType
    public static let date: walletverse_ios_sdk.GDatabase.ColumnType
    public static let datetime: walletverse_ios_sdk.GDatabase.ColumnType
    public typealias RawValue = Swift.String
  }
  public enum ConflictResolution : Swift.String {
    case rollback
    case abort
    case fail
    case ignore
    case replace
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ForeignKeyAction : Swift.String {
    case cascade
    case restrict
    case setNull
    case setDefault
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias LogErrorFunction = (_ resultCode: walletverse_ios_sdk.ResultCode, _ message: Swift.String) -> Swift.Void
  public enum TransactionCompletion {
    case commit
    case rollback
    public static func == (a: walletverse_ios_sdk.GDatabase.TransactionCompletion, b: walletverse_ios_sdk.GDatabase.TransactionCompletion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum TransactionKind : Swift.String {
    case deferred
    case immediate
    case exclusive
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public struct HasOneAssociation<Origin, Destination> : walletverse_ios_sdk.Association {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
  public var _impl: walletverse_ios_sdk.JoinAssociationImpl
  public init(_impl: walletverse_ios_sdk.JoinAssociationImpl)
  public typealias Impl = walletverse_ios_sdk.JoinAssociationImpl
}
extension walletverse_ios_sdk.HasOneAssociation : walletverse_ios_sdk.TableRequest where Destination : walletverse_ios_sdk.TableRecord {
  public var databaseTableName: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.TableRecord {
  public static func hasOne<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: walletverse_ios_sdk.ForeignKey? = nil) -> walletverse_ios_sdk.HasOneAssociation<Self, Destination> where Destination : walletverse_ios_sdk.TableRecord
}
public enum Task {
  case requestPlain
  case requestData(Foundation.Data)
  case requestJSONEncodable(Swift.Encodable)
  case requestCustomJSONEncodable(Swift.Encodable, encoder: Foundation.JSONEncoder)
  case requestParameters(parameters: [Swift.String : Any], encoding: walletverse_ios_sdk.ParameterEncoding)
  case requestCompositeData(bodyData: Foundation.Data, urlParameters: [Swift.String : Any])
  case requestCompositeParameters(bodyParameters: [Swift.String : Any], bodyEncoding: walletverse_ios_sdk.ParameterEncoding, urlParameters: [Swift.String : Any])
  case uploadFile(Foundation.URL)
  case uploadMultipart([walletverse_ios_sdk.MultipartFormData])
  case uploadCompositeMultipart([walletverse_ios_sdk.MultipartFormData], urlParameters: [Swift.String : Any])
  case downloadDestination(walletverse_ios_sdk.DownloadDestination)
  case downloadParameters(parameters: [Swift.String : Any], encoding: walletverse_ios_sdk.ParameterEncoding, destination: walletverse_ios_sdk.DownloadDestination)
}
@objc @_inheritsConvenienceInitializers public class DefaultUtil : ObjectiveC.NSObject {
  public static func initDefault()
  public static func getValue(key: Swift.String) -> Any
  public static func getBoolValue(key: Swift.String) -> Swift.Bool
  public static func setValue(value: Any, key: Swift.String)
  public static func clearValue(key: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public typealias Completion = (_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>) -> Swift.Void
public typealias ProgressBlock = (_ progress: walletverse_ios_sdk.ProgressResponse) -> Swift.Void
public struct ProgressResponse {
  public let response: walletverse_ios_sdk.Response?
  public let progressObject: Foundation.Progress?
  public init(progress: Foundation.Progress? = nil, response: walletverse_ios_sdk.Response? = nil)
  public var progress: Swift.Double {
    get
  }
  public var completed: Swift.Bool {
    get
  }
}
public protocol MoyaProviderType : AnyObject {
  associatedtype Target : walletverse_ios_sdk.TargetType
  func request(_ target: Self.Target, callbackQueue: Dispatch.DispatchQueue?, progress: walletverse_ios_sdk.ProgressBlock?, completion: @escaping walletverse_ios_sdk.Completion) -> walletverse_ios_sdk.Cancellable
}
open class MoyaProvider<Target> : walletverse_ios_sdk.MoyaProviderType where Target : walletverse_ios_sdk.TargetType {
  public typealias EndpointClosure = (Target) -> walletverse_ios_sdk.Endpoint
  public typealias RequestResultClosure = (walletverse_ios_sdk.RResult<Foundation.URLRequest, walletverse_ios_sdk.MoyaError>) -> Swift.Void
  public typealias RequestClosure = (walletverse_ios_sdk.Endpoint, @escaping walletverse_ios_sdk.MoyaProvider<Target>.RequestResultClosure) -> Swift.Void
  public typealias StubClosure = (Target) -> walletverse_ios_sdk.StubBehavior
  final public let endpointClosure: walletverse_ios_sdk.MoyaProvider<Target>.EndpointClosure
  final public let requestClosure: walletverse_ios_sdk.MoyaProvider<Target>.RequestClosure
  final public let stubClosure: walletverse_ios_sdk.MoyaProvider<Target>.StubClosure
  final public let manager: walletverse_ios_sdk.Manager
  final public let plugins: [walletverse_ios_sdk.PluginType]
  final public let trackInflights: Swift.Bool
  open var inflightRequests: [walletverse_ios_sdk.Endpoint : [walletverse_ios_sdk.Completion]] {
    get
  }
  public init(endpointClosure: @escaping walletverse_ios_sdk.MoyaProvider<Target>.EndpointClosure = MoyaProvider.defaultEndpointMapping, requestClosure: @escaping walletverse_ios_sdk.MoyaProvider<Target>.RequestClosure = MoyaProvider.defaultRequestMapping, stubClosure: @escaping walletverse_ios_sdk.MoyaProvider<Target>.StubClosure = MoyaProvider.neverStub, callbackQueue: Dispatch.DispatchQueue? = nil, manager: walletverse_ios_sdk.Manager = MoyaProvider<Target>.defaultAlamofireManager(), plugins: [walletverse_ios_sdk.PluginType] = [], trackInflights: Swift.Bool = false)
  open func endpoint(_ token: Target) -> walletverse_ios_sdk.Endpoint
  @discardableResult
  open func request(_ target: Target, callbackQueue: Dispatch.DispatchQueue? = .none, progress: walletverse_ios_sdk.ProgressBlock? = .none, completion: @escaping walletverse_ios_sdk.Completion) -> walletverse_ios_sdk.Cancellable
  @discardableResult
  open func stubRequest(_ target: Target, request: Foundation.URLRequest, callbackQueue: Dispatch.DispatchQueue?, completion: @escaping walletverse_ios_sdk.Completion, endpoint: walletverse_ios_sdk.Endpoint, stubBehavior: walletverse_ios_sdk.StubBehavior) -> walletverse_ios_sdk.CancellableToken
  @objc deinit
}
public enum StubBehavior {
  case never
  case immediate
  case delayed(seconds: Foundation.TimeInterval)
}
extension walletverse_ios_sdk.MoyaProvider {
  final public class func neverStub(_: Target) -> walletverse_ios_sdk.StubBehavior
  final public class func immediatelyStub(_: Target) -> walletverse_ios_sdk.StubBehavior
  final public class func delayedStub(_ seconds: Foundation.TimeInterval) -> (Target) -> walletverse_ios_sdk.StubBehavior
}
public func convertResponseToResult(_ response: Foundation.HTTPURLResponse?, request: Foundation.URLRequest?, data: Foundation.Data?, error: Swift.Error?) -> walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>
extension walletverse_ios_sdk.ValueObservation {
  public func mapReducer<R>(_ transform: @escaping (walletverse_ios_sdk.GDatabase, Reducer) throws -> R) -> walletverse_ios_sdk.ValueObservation<R>
}
final public class CredentialsPlugin : walletverse_ios_sdk.PluginType {
  public typealias CredentialClosure = (walletverse_ios_sdk.TargetType) -> Foundation.URLCredential?
  public init(credentialsClosure: @escaping walletverse_ios_sdk.CredentialsPlugin.CredentialClosure)
  final public func willSend(_ request: walletverse_ios_sdk.RequestType, target: walletverse_ios_sdk.TargetType)
  @objc deinit
}
public struct FTS4 : walletverse_ios_sdk.VirtualTableModule {
  public init()
  public let moduleName: Swift.String
  public func makeTableDefinition() -> walletverse_ios_sdk.FTS4TableDefinition
  public func moduleArguments(for definition: walletverse_ios_sdk.FTS4TableDefinition, in db: walletverse_ios_sdk.GDatabase) -> [Swift.String]
  public func database(_ db: walletverse_ios_sdk.GDatabase, didCreate tableName: Swift.String, using definition: walletverse_ios_sdk.FTS4TableDefinition) throws
  public typealias TableDefinition = walletverse_ios_sdk.FTS4TableDefinition
}
@_hasMissingDesignatedInitializers final public class FTS4TableDefinition {
  final public var tokenizer: walletverse_ios_sdk.FTS3TokenizerDescriptor?
  final public var content: Swift.String? {
    get
    set
  }
  final public var compress: Swift.String?
  final public var uncompress: Swift.String?
  final public var matchinfo: Swift.String?
  final public var prefixes: Swift.Set<Swift.Int>?
  @discardableResult
  final public func column(_ name: Swift.String) -> walletverse_ios_sdk.FTS4ColumnDefinition
  final public func synchronize(withTable tableName: Swift.String)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FTS4ColumnDefinition {
  @available(iOS 8.2, macOS 10.10, *)
  @discardableResult
  final public func notIndexed() -> Self
  @discardableResult
  final public func asLanguageId() -> Self
  @objc deinit
}
extension walletverse_ios_sdk.GDatabase {
  final public func dropFTS4SynchronizationTriggers(forTable tableName: Swift.String) throws
}
extension walletverse_ios_sdk.FetchableRecord where Self : Swift.Decodable {
  public init(row: walletverse_ios_sdk.Row)
}
public struct HasManyAssociation<Origin, Destination> : walletverse_ios_sdk.Association {
  public typealias OriginRowDecoder = Origin
  public typealias RowDecoder = Destination
  public var _impl: walletverse_ios_sdk.JoinAssociationImpl
  public init(_impl: walletverse_ios_sdk.JoinAssociationImpl)
  public typealias Impl = walletverse_ios_sdk.JoinAssociationImpl
}
extension walletverse_ios_sdk.HasManyAssociation : walletverse_ios_sdk.TableRequest where Destination : walletverse_ios_sdk.TableRecord {
  public var databaseTableName: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.HasManyAssociation where Origin : walletverse_ios_sdk.TableRecord, Destination : walletverse_ios_sdk.TableRecord {
  public var count: walletverse_ios_sdk.AssociationAggregate<Origin> {
    get
  }
  public var isEmpty: walletverse_ios_sdk.AssociationAggregate<Origin> {
    get
  }
  public func average(_ expression: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<Origin>
  public func max(_ expression: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<Origin>
  public func min(_ expression: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<Origin>
  public func sum(_ expression: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.AssociationAggregate<Origin>
}
extension walletverse_ios_sdk.TableRecord {
  public static func hasMany<Destination>(_ destination: Destination.Type, key: Swift.String? = nil, using foreignKey: walletverse_ios_sdk.ForeignKey? = nil) -> walletverse_ios_sdk.HasManyAssociation<Self, Destination> where Destination : walletverse_ios_sdk.TableRecord
}
final public class DatabaseCollation {
  final public let name: Swift.String
  public init(_ name: Swift.String, function: @escaping (Swift.String, Swift.String) -> Foundation.ComparisonResult)
  @objc deinit
}
extension walletverse_ios_sdk.DatabaseCollation : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: walletverse_ios_sdk.DatabaseCollation, rhs: walletverse_ios_sdk.DatabaseCollation) -> Swift.Bool
  final public var hashValue: Swift.Int {
    get
  }
}
public protocol _ExtendCustomModelType : walletverse_ios_sdk._Transformable {
  init()
  mutating func willStartMapping()
  mutating func mapping(mapper: walletverse_ios_sdk.HelpingMapper)
  mutating func didFinishMapping()
}
extension walletverse_ios_sdk._ExtendCustomModelType {
  public mutating func willStartMapping()
  public mutating func mapping(mapper: walletverse_ios_sdk.HelpingMapper)
  public mutating func didFinishMapping()
}
public struct QueryInterfaceRequest<T> {
}
extension walletverse_ios_sdk.QueryInterfaceRequest : walletverse_ios_sdk.FetchRequest {
  public typealias RowDecoder = T
  public func prepare(_ db: walletverse_ios_sdk.GDatabase) throws -> (walletverse_ios_sdk.SelectStatement, walletverse_ios_sdk.RowAdapter?)
  public func fetchCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
  public func databaseRegion(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseRegion
}
extension walletverse_ios_sdk.QueryInterfaceRequest : walletverse_ios_sdk.DerivableRequest, walletverse_ios_sdk.AggregatingRequest {
  public func select(_ selection: [walletverse_ios_sdk.SQLSelectable]) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func select<RowDecoder>(_ selection: [walletverse_ios_sdk.SQLSelectable], as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public func select<RowDecoder>(_ selection: walletverse_ios_sdk.SQLSelectable..., as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public func select<RowDecoder>(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public func annotated(with selection: [walletverse_ios_sdk.SQLSelectable]) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func distinct() -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func filter(_ predicate: @escaping (walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func group(_ expressions: @escaping (walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.SQLExpressible]) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func having(_ predicate: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func order(_ orderings: @escaping (walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.SQLOrderingTerm]) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func reversed() -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func aliased(_ alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
  public func asRequest<RowDecoder>(of type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
}
extension walletverse_ios_sdk.QueryInterfaceRequest : walletverse_ios_sdk.TableRequest where T : walletverse_ios_sdk.TableRecord {
  public var databaseTableName: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.QueryInterfaceRequest where T : walletverse_ios_sdk.MutablePersistableRecord {
  @discardableResult
  public func deleteAll(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
extension walletverse_ios_sdk.TableRecord {
  public static func all() -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func none() -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func select(_ selection: walletverse_ios_sdk.SQLSelectable...) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func select(_ selection: [walletverse_ios_sdk.SQLSelectable]) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func select(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func select<RowDecoder>(_ selection: [walletverse_ios_sdk.SQLSelectable], as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(_ selection: walletverse_ios_sdk.SQLSelectable..., as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public static func select<RowDecoder>(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, as type: RowDecoder.Type) -> walletverse_ios_sdk.QueryInterfaceRequest<RowDecoder>
  public static func filter(_ predicate: walletverse_ios_sdk.SQLExpressible) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func filter<PrimaryKeyType>(key: PrimaryKeyType?) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where PrimaryKeyType : walletverse_ios_sdk.DatabaseValueConvertible
  public static func filter<Sequence>(keys: Sequence) -> walletverse_ios_sdk.QueryInterfaceRequest<Self> where Sequence : Swift.Sequence, Sequence.Element : walletverse_ios_sdk.DatabaseValueConvertible
  public static func filter(key: [Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]?) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func filter(keys: [[Swift.String : walletverse_ios_sdk.DatabaseValueConvertible?]]) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func filter(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func order(_ orderings: walletverse_ios_sdk.SQLOrderingTerm...) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func order(_ orderings: [walletverse_ios_sdk.SQLOrderingTerm]) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func orderByPrimaryKey() -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func order(sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func limit(_ limit: Swift.Int, offset: Swift.Int? = nil) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
  public static func aliased(_ alias: walletverse_ios_sdk.TableAlias) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> walletverse_ios_sdk.AResult<Self.SerializedObject> { get }
}
public struct DataResponseSerializer<Value> : walletverse_ios_sdk.DataResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> walletverse_ios_sdk.AResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, Swift.Error?) -> walletverse_ios_sdk.AResult<Value>)
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> walletverse_ios_sdk.AResult<Self.SerializedObject> { get }
}
public struct DownloadResponseSerializer<Value> : walletverse_ios_sdk.DownloadResponseSerializerProtocol {
  public typealias SerializedObject = Value
  public var serializeResponse: (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> walletverse_ios_sdk.AResult<Value>
  public init(serializeResponse: @escaping (Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.URL?, Swift.Error?) -> walletverse_ios_sdk.AResult<Value>)
}
extension walletverse_ios_sdk.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (walletverse_ios_sdk.DefaultDataResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (walletverse_ios_sdk.DataResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : walletverse_ios_sdk.DataResponseSerializerProtocol
}
extension walletverse_ios_sdk.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (walletverse_ios_sdk.DefaultDownloadResponse) -> Swift.Void) -> Self
  @discardableResult
  public func response<T>(queue: Dispatch.DispatchQueue? = nil, responseSerializer: T, completionHandler: @escaping (walletverse_ios_sdk.DownloadResponse<T.SerializedObject>) -> Swift.Void) -> Self where T : walletverse_ios_sdk.DownloadResponseSerializerProtocol
}
extension walletverse_ios_sdk.ARequest {
  public static func serializeResponseData(response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> walletverse_ios_sdk.AResult<Foundation.Data>
}
extension walletverse_ios_sdk.DataRequest {
  public static func dataResponseSerializer() -> walletverse_ios_sdk.DataResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (walletverse_ios_sdk.DataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.DownloadRequest {
  public static func dataResponseSerializer() -> walletverse_ios_sdk.DownloadResponseSerializer<Foundation.Data>
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue? = nil, completionHandler: @escaping (walletverse_ios_sdk.DownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.ARequest {
  public static func serializeResponseString(encoding: Swift.String.Encoding?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> walletverse_ios_sdk.AResult<Swift.String>
}
extension walletverse_ios_sdk.DataRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> walletverse_ios_sdk.DataResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (walletverse_ios_sdk.DataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.DownloadRequest {
  public static func stringResponseSerializer(encoding: Swift.String.Encoding? = nil) -> walletverse_ios_sdk.DownloadResponseSerializer<Swift.String>
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue? = nil, encoding: Swift.String.Encoding? = nil, completionHandler: @escaping (walletverse_ios_sdk.DownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.ARequest {
  public static func serializeResponseJSON(options: Foundation.JSONSerialization.ReadingOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> walletverse_ios_sdk.AResult<Any>
}
extension walletverse_ios_sdk.DataRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> walletverse_ios_sdk.DataResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (walletverse_ios_sdk.DataResponse<Any>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.DownloadRequest {
  public static func jsonResponseSerializer(options: Foundation.JSONSerialization.ReadingOptions = .allowFragments) -> walletverse_ios_sdk.DownloadResponseSerializer<Any>
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue? = nil, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (walletverse_ios_sdk.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.ARequest {
  public static func serializeResponsePropertyList(options: Foundation.PropertyListSerialization.ReadOptions, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) -> walletverse_ios_sdk.AResult<Any>
}
extension walletverse_ios_sdk.DataRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> walletverse_ios_sdk.DataResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (walletverse_ios_sdk.DataResponse<Any>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.DownloadRequest {
  public static func propertyListResponseSerializer(options: Foundation.PropertyListSerialization.ReadOptions = []) -> walletverse_ios_sdk.DownloadResponseSerializer<Any>
  @discardableResult
  public func responsePropertyList(queue: Dispatch.DispatchQueue? = nil, options: Foundation.PropertyListSerialization.ReadOptions = [], completionHandler: @escaping (walletverse_ios_sdk.DownloadResponse<Any>) -> Swift.Void) -> Self
}
extension walletverse_ios_sdk.MoyaProvider {
  open func requestData<T>(_ target: Target, model: T.Type, completion: ((_ returnData: T?) -> Swift.Void)?) -> walletverse_ios_sdk.Cancellable? where T : walletverse_ios_sdk.HandyJSON
  open func requestAll<T>(_ target: Target, model: T.Type, completion: ((_ returnData: T?) -> Swift.Void)?) -> walletverse_ios_sdk.Cancellable? where T : walletverse_ios_sdk.HandyJSON
  open func requestAllDict(_ target: Target, completion: ((_ returnData: [Swift.String : Any]?) -> Swift.Void)?) -> walletverse_ios_sdk.Cancellable?
}
extension Swift.Array : walletverse_ios_sdk.HandyJSON {
}
extension Swift.Dictionary : walletverse_ios_sdk.HandyJSON {
}
public enum NetworkActivityChangeType {
  case began, ended
  public static func == (a: walletverse_ios_sdk.NetworkActivityChangeType, b: walletverse_ios_sdk.NetworkActivityChangeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class NetworkActivityPlugin : walletverse_ios_sdk.PluginType {
  public typealias NetworkActivityClosure = (_ change: walletverse_ios_sdk.NetworkActivityChangeType, _ target: walletverse_ios_sdk.TargetType) -> Swift.Void
  public init(networkActivityClosure: @escaping walletverse_ios_sdk.NetworkActivityPlugin.NetworkActivityClosure)
  final public func willSend(_ request: walletverse_ios_sdk.RequestType, target: walletverse_ios_sdk.TargetType)
  final public func didReceive(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType)
  @objc deinit
}
extension walletverse_ios_sdk.FetchRequest {
  @available(*, unavailable, message: "Use QueryInterfaceRequest.asRequest(of:), or AnyFetchRequest")
  public func bound<T>(to type: T.Type) -> walletverse_ios_sdk.AnyFetchRequest<T>
}
@_silgen_name("swift_getTypeByMangledNameInContext")
public func _getTypeByMangledNameInContext(_ name: Swift.UnsafePointer<Swift.UInt8>, _ nameLength: Swift.Int, genericContext: Swift.UnsafeRawPointer?, genericArguments: Swift.UnsafeRawPointer?) -> Any.Type?
@_silgen_name("swift_getTypeContextDescriptor")
public func _swift_getTypeContextDescriptor(_ metadata: Swift.UnsafeRawPointer?) -> Swift.UnsafeRawPointer?
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func trackingAll<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.RowsReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder == walletverse_ios_sdk.Row
  public static func trackingOne<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.RowReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder == walletverse_ios_sdk.Row
}
public struct RowsReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder == walletverse_ios_sdk.Row {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.Row]
  public mutating func value(_ rows: [walletverse_ios_sdk.Row]) -> [walletverse_ios_sdk.Row]?
  public typealias Fetched = [walletverse_ios_sdk.Row]
  public typealias Value = [walletverse_ios_sdk.Row]
}
public struct RowReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder == walletverse_ios_sdk.Row {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.Row?
  public mutating func value(_ row: walletverse_ios_sdk.Row?) -> walletverse_ios_sdk.Row??
  public typealias Fetched = walletverse_ios_sdk.Row?
  public typealias Value = walletverse_ios_sdk.Row?
}
extension ObjectiveC.NSObject {
  public static func swizzleMethodSDK(_ cls: Swift.AnyClass, originalSelector: ObjectiveC.Selector, swizzleSelector: ObjectiveC.Selector)
}
public var currentVCSDK: UIKit.UIViewController? {
  get
}
public enum NoError : Swift.Error, Swift.Equatable {
  public static func == (lhs: walletverse_ios_sdk.NoError, rhs: walletverse_ios_sdk.NoError) -> Swift.Bool
}
extension Foundation.NSUUID : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension Foundation.UUID : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Foundation.UUID?
}
extension Foundation.UUID : walletverse_ios_sdk.StatementColumnConvertible {
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
}
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
extension walletverse_ios_sdk.QueryInterfaceRequest {
  public func matching(_ pattern: walletverse_ios_sdk.FTS3Pattern?) -> walletverse_ios_sdk.QueryInterfaceRequest<T>
}
extension walletverse_ios_sdk.TableRecord {
  public static func matching(_ pattern: walletverse_ios_sdk.FTS3Pattern?) -> walletverse_ios_sdk.QueryInterfaceRequest<Self>
}
extension walletverse_ios_sdk.ColumnExpression {
  public func match(_ pattern: walletverse_ios_sdk.FTS3Pattern?) -> walletverse_ios_sdk.SQLExpression
}
extension Foundation.NSNull : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func trackingAll<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.DatabaseValuesReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible
  public static func trackingOne<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.DatabaseValueReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible
  public static func trackingAll<Request>(_ request: Request) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.OptionalDatabaseValuesReducer<Request>> where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk._OptionalProtocol, Request.RowDecoder._Wrapped : walletverse_ios_sdk.DatabaseValueConvertible
}
public struct DatabaseValuesReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.DatabaseValue]
  public mutating func value(_ dbValues: [walletverse_ios_sdk.DatabaseValue]) -> [Request.RowDecoder]?
  public typealias Fetched = [walletverse_ios_sdk.DatabaseValue]
  public typealias Value = [Request.RowDecoder]
}
public struct DatabaseValueReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk.DatabaseValueConvertible {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.DatabaseValue?
  public mutating func value(_ dbValue: walletverse_ios_sdk.DatabaseValue?) -> Request.RowDecoder??
  public typealias Fetched = walletverse_ios_sdk.DatabaseValue?
  public typealias Value = Request.RowDecoder?
}
public struct OptionalDatabaseValuesReducer<Request> : walletverse_ios_sdk.ValueReducer where Request : walletverse_ios_sdk.FetchRequest, Request.RowDecoder : walletverse_ios_sdk._OptionalProtocol, Request.RowDecoder._Wrapped : walletverse_ios_sdk.DatabaseValueConvertible {
  public let request: Request
  public func fetch(_ db: walletverse_ios_sdk.GDatabase) throws -> [walletverse_ios_sdk.DatabaseValue]
  public mutating func value(_ dbValues: [walletverse_ios_sdk.DatabaseValue]) -> [Request.RowDecoder._Wrapped?]?
  public typealias Fetched = [walletverse_ios_sdk.DatabaseValue]
  public typealias Value = [Request.RowDecoder._Wrapped?]
}
public protocol _ExtendCustomBasicType : walletverse_ios_sdk._Transformable {
  static func _transform(from object: Any) -> Self?
  func _plainValue() -> Any?
}
extension Foundation.NSData : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> Self?
}
extension walletverse_ios_sdk.MoyaProvider {
  final public class func defaultEndpointMapping(for target: Target) -> walletverse_ios_sdk.Endpoint
  final public class func defaultRequestMapping(for endpoint: walletverse_ios_sdk.Endpoint, closure: (walletverse_ios_sdk.RResult<Foundation.URLRequest, walletverse_ios_sdk.MoyaError>) -> Swift.Void)
  final public class func defaultAlamofireManager() -> walletverse_ios_sdk.Manager
}
public protocol _Transformable : walletverse_ios_sdk._Measurable {
}
public protocol _Measurable {
}
public protocol Cancellable {
  var isCancelled: Swift.Bool { get }
  func cancel()
}
public struct FTS3Pattern {
  public let rawPattern: Swift.String
  public init(rawPattern: Swift.String) throws
  @available(iOS 8.2, macOS 10.10, *)
  public init?(matchingAnyTokenIn string: Swift.String)
  @available(iOS 8.2, macOS 10.10, *)
  public init?(matchingAllTokensIn string: Swift.String)
  @available(iOS 8.2, macOS 10.10, *)
  public init?(matchingPhrase string: Swift.String)
}
extension walletverse_ios_sdk.FTS3Pattern : walletverse_ios_sdk.DatabaseValueConvertible {
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> walletverse_ios_sdk.FTS3Pattern?
}
public protocol DatabaseWriter : walletverse_ios_sdk.DatabaseReader {
  func write<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  func writeWithoutTransaction<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  func unsafeReentrantWrite<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  @available(*, deprecated, message: "Use concurrentRead instead")
  func readFromCurrentState(_ block: @escaping (walletverse_ios_sdk.GDatabase) -> Swift.Void) throws
  func concurrentRead<T>(_ block: @escaping (walletverse_ios_sdk.GDatabase) throws -> T) -> walletverse_ios_sdk.Future<T>
}
extension walletverse_ios_sdk.DatabaseWriter {
  public func add(transactionObserver: walletverse_ios_sdk.TransactionObserver, extent: walletverse_ios_sdk.GDatabase.TransactionObservationExtent = .observerLifetime)
  public func remove(transactionObserver: walletverse_ios_sdk.TransactionObserver)
  public func erase() throws
  public func vacuum() throws
  public func add<Reducer>(observation: walletverse_ios_sdk.ValueObservation<Reducer>, onError: ((Swift.Error) -> Swift.Void)?, onChange: @escaping (Reducer.Value) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver where Reducer : walletverse_ios_sdk.ValueReducer
}
@_hasMissingDesignatedInitializers public class Future<Value> {
  public func wait() throws -> Value
  @objc deinit
}
final public class AnyDatabaseWriter : walletverse_ios_sdk.DatabaseWriter {
  public init(_ base: walletverse_ios_sdk.DatabaseWriter)
  final public func read<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func unsafeReentrantRead<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  @available(*, deprecated, message: "Use concurrentRead instead")
  final public func readFromCurrentState(_ block: @escaping (walletverse_ios_sdk.GDatabase) -> Swift.Void) throws
  final public func concurrentRead<T>(_ block: @escaping (walletverse_ios_sdk.GDatabase) throws -> T) -> walletverse_ios_sdk.Future<T>
  final public func write<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) throws -> T
  final public func writeWithoutTransaction<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func unsafeReentrantWrite<T>(_ block: (walletverse_ios_sdk.GDatabase) throws -> T) rethrows -> T
  final public func add(function: walletverse_ios_sdk.DatabaseFunction)
  final public func remove(function: walletverse_ios_sdk.DatabaseFunction)
  final public func add(collation: walletverse_ios_sdk.DatabaseCollation)
  final public func remove(collation: walletverse_ios_sdk.DatabaseCollation)
  @objc deinit
}
open class TransformOf<ObjectType, JSONType> : walletverse_ios_sdk.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
public protocol SQLExpressible {
  var sqlExpression: walletverse_ios_sdk.SQLExpression { get }
}
public protocol SQLSpecificExpressible : walletverse_ios_sdk.SQLExpressible {
}
extension walletverse_ios_sdk.SQLExpressible where Self : walletverse_ios_sdk.SQLOrderingTerm {
  public var reversed: walletverse_ios_sdk.SQLOrderingTerm {
    get
  }
  public func orderingTermSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
}
extension walletverse_ios_sdk.SQLExpressible where Self : walletverse_ios_sdk.SQLSelectable {
  public func resultColumnSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func countedSQL(_ context: inout walletverse_ios_sdk.SQLGenerationContext) -> Swift.String
  public func count(distinct: Swift.Bool) -> walletverse_ios_sdk.SQLCount?
  public func columnCount(_ db: walletverse_ios_sdk.GDatabase) throws -> Swift.Int
}
public protocol FetchableRecord {
  init(row: walletverse_ios_sdk.Row)
  static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] { get }
  static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  static var databaseDateDecodingStrategy: walletverse_ios_sdk.DatabaseDateDecodingStrategy { get }
}
extension walletverse_ios_sdk.FetchableRecord {
  public static var databaseDecodingUserInfo: [Swift.CodingUserInfoKey : Any] {
    get
  }
  public static func databaseJSONDecoder(for column: Swift.String) -> Foundation.JSONDecoder
  public static var databaseDateDecodingStrategy: walletverse_ios_sdk.DatabaseDateDecodingStrategy {
    get
  }
}
extension walletverse_ios_sdk.FetchableRecord {
  public static func fetchCursor(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.RecordCursor<Self>
  public static func fetchAll(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ statement: walletverse_ios_sdk.SelectStatement, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.FetchableRecord {
  public static func fetchCursor(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> walletverse_ios_sdk.RecordCursor<Self>
  public static func fetchAll(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> [Self]
  public static func fetchOne(_ db: walletverse_ios_sdk.GDatabase, _ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil, adapter: walletverse_ios_sdk.RowAdapter? = nil) throws -> Self?
}
extension walletverse_ios_sdk.FetchableRecord {
  public static func fetchCursor<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> walletverse_ios_sdk.RecordCursor<Self> where R : walletverse_ios_sdk.FetchRequest
  public static func fetchAll<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> [Self] where R : walletverse_ios_sdk.FetchRequest
  public static func fetchOne<R>(_ db: walletverse_ios_sdk.GDatabase, _ request: R) throws -> Self? where R : walletverse_ios_sdk.FetchRequest
}
extension walletverse_ios_sdk.FetchRequest where Self.RowDecoder : walletverse_ios_sdk.FetchableRecord {
  public func fetchCursor(_ db: walletverse_ios_sdk.GDatabase) throws -> walletverse_ios_sdk.RecordCursor<Self.RowDecoder>
  public func fetchAll(_ db: walletverse_ios_sdk.GDatabase) throws -> [Self.RowDecoder]
  public func fetchOne(_ db: walletverse_ios_sdk.GDatabase) throws -> Self.RowDecoder?
}
@_hasMissingDesignatedInitializers final public class RecordCursor<Record> : walletverse_ios_sdk.Cursor where Record : walletverse_ios_sdk.FetchableRecord {
  @objc deinit
  final public func next() throws -> Record?
  public typealias Element = Record
}
public enum DatabaseDateDecodingStrategy {
  case deferredToDate
  case timeIntervalSinceReferenceDate
  case timeIntervalSince1970
  case millisecondsSince1970
  @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  case iso8601
  case formatted(Foundation.DateFormatter)
  case custom((walletverse_ios_sdk.DatabaseValue) -> Foundation.Date?)
}
final public class NetworkLoggerPlugin : walletverse_ios_sdk.PluginType {
  final public let isVerbose: Swift.Bool
  final public let cURL: Swift.Bool
  public init(verbose: Swift.Bool = false, cURL: Swift.Bool = false, output: ((_ separator: Swift.String, _ terminator: Swift.String, _ items: Any...) -> Swift.Void)? = nil, requestDataFormatter: ((Foundation.Data) -> (Swift.String))? = nil, responseDataFormatter: ((Foundation.Data) -> (Foundation.Data))? = nil)
  final public func willSend(_ request: walletverse_ios_sdk.RequestType, target: walletverse_ios_sdk.TargetType)
  final public func didReceive(_ result: walletverse_ios_sdk.RResult<walletverse_ios_sdk.Response, walletverse_ios_sdk.MoyaError>, target: walletverse_ios_sdk.TargetType)
  @objc deinit
}
extension Swift.Array {
  public init<C>(_ cursor: C) throws where Element == C.Element, C : walletverse_ios_sdk.Cursor
}
extension Swift.Sequence {
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Iterator.Element) throws -> SegmentOfResult) -> walletverse_ios_sdk.FlattenCursor<walletverse_ios_sdk.MapCursor<walletverse_ios_sdk.AnyCursor<Self.Iterator.Element>, SegmentOfResult>> where SegmentOfResult : walletverse_ios_sdk.Cursor
}
extension Swift.Set {
  public init<C>(_ cursor: C) throws where Element == C.Element, C : walletverse_ios_sdk.Cursor
}
public protocol Cursor : AnyObject {
  associatedtype Element
  func next() throws -> Self.Element?
}
extension walletverse_ios_sdk.Cursor {
  public func isEmpty() throws -> Swift.Bool
  public func contains(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Swift.Bool
  public func enumerated() -> walletverse_ios_sdk.EnumeratedCursor<Self>
  public func filter(_ isIncluded: @escaping (Self.Element) throws -> Swift.Bool) -> walletverse_ios_sdk.FilterCursor<Self>
  public func first(where predicate: (Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func compactMap<ElementOfResult>(_ transform: @escaping (Self.Element) throws -> ElementOfResult?) -> walletverse_ios_sdk.MapCursor<walletverse_ios_sdk.FilterCursor<walletverse_ios_sdk.MapCursor<Self, ElementOfResult?>>, ElementOfResult>
  @available(*, deprecated, renamed: "compactMap")
  public func flatMap<ElementOfResult>(_ transform: @escaping (Self.Element) throws -> ElementOfResult?) -> walletverse_ios_sdk.MapCursor<walletverse_ios_sdk.FilterCursor<walletverse_ios_sdk.MapCursor<Self, ElementOfResult?>>, ElementOfResult>
  public func drop(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> walletverse_ios_sdk.DropWhileCursor<Self>
  public func dropFirst(_ n: Swift.Int) -> walletverse_ios_sdk.DropFirstCursor<Self>
  public func dropFirst() -> walletverse_ios_sdk.DropFirstCursor<Self>
  public func dropLast(_ n: Swift.Int) throws -> [Self.Element]
  public func dropLast() throws -> [Self.Element]
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> walletverse_ios_sdk.FlattenCursor<walletverse_ios_sdk.MapCursor<Self, walletverse_ios_sdk.AnyCursor<SegmentOfResult.Element>>> where SegmentOfResult : Swift.Sequence
  public func flatMap<SegmentOfResult>(_ transform: @escaping (Self.Element) throws -> SegmentOfResult) -> walletverse_ios_sdk.FlattenCursor<walletverse_ios_sdk.MapCursor<Self, SegmentOfResult>> where SegmentOfResult : walletverse_ios_sdk.Cursor
  public func forEach(_ body: (Self.Element) throws -> Swift.Void) throws
  public func map<T>(_ transform: @escaping (Self.Element) throws -> T) -> walletverse_ios_sdk.MapCursor<Self, T>
  public func max(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func min(by areInIncreasingOrder: (Self.Element, Self.Element) throws -> Swift.Bool) throws -> Self.Element?
  public func prefix(_ maxLength: Swift.Int) -> walletverse_ios_sdk.PrefixCursor<Self>
  public func prefix(while predicate: @escaping (Self.Element) throws -> Swift.Bool) -> walletverse_ios_sdk.PrefixWhileCursor<Self>
  public func reduce<Result>(_ initialResult: Result, _ nextPartialResult: (Result, Self.Element) throws -> Result) throws -> Result
  public func reduce<Result>(into initialResult: Result, _ updateAccumulatingResult: (inout Result, Self.Element) throws -> Swift.Void) throws -> Result
  public func suffix(_ maxLength: Swift.Int) throws -> [Self.Element]
}
extension walletverse_ios_sdk.Cursor where Self.Element : Swift.Equatable {
  public func contains(_ element: Self.Element) throws -> Swift.Bool
}
extension walletverse_ios_sdk.Cursor where Self.Element : Swift.Comparable {
  public func max() throws -> Self.Element?
  public func min() throws -> Self.Element?
}
extension walletverse_ios_sdk.Cursor where Self.Element : walletverse_ios_sdk.Cursor {
  public func joined() -> walletverse_ios_sdk.FlattenCursor<Self>
}
extension walletverse_ios_sdk.Cursor where Self.Element : Swift.Sequence {
  public func joined() -> walletverse_ios_sdk.FlattenCursor<walletverse_ios_sdk.MapCursor<Self, walletverse_ios_sdk.AnyCursor<Self.Element.Element>>>
}
extension walletverse_ios_sdk.Cursor where Self.Element : Swift.StringProtocol {
  public func joined(separator: Swift.String = "") throws -> Swift.String
}
final public class AnyCursor<Element> : walletverse_ios_sdk.Cursor {
  public init<C>(_ base: C) where Element == C.Element, C : walletverse_ios_sdk.Cursor
  convenience public init<I>(iterator: I) where Element == I.Element, I : Swift.IteratorProtocol
  convenience public init<S>(_ s: S) where Element == S.Element, S : Swift.Sequence
  public init(_ body: @escaping () throws -> Element?)
  final public func next() throws -> Element?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DropFirstCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DropWhileCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class EnumeratedCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> (Swift.Int, Base.Element)?
  public typealias Element = (Swift.Int, Base.Element)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FilterCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FlattenCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor, Base.Element : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element.Element?
  public typealias Element = Base.Element.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class MapCursor<Base, Element> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Element?
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PrefixCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PrefixWhileCursor<Base> : walletverse_ios_sdk.Cursor where Base : walletverse_ios_sdk.Cursor {
  final public func next() throws -> Base.Element?
  public typealias Element = Base.Element
  @objc deinit
}
extension Foundation.URL {
  public init<T>(target: T) where T : walletverse_ios_sdk.TargetType
}
public class JSCoreParams : walletverse_ios_sdk.HandyJSON {
  public var parmeters: [Swift.String : Any]?
  required public init()
  public func putOther(key: Swift.String, value: Any)
  public func put(key: Swift.String, value: Any) -> walletverse_ios_sdk.JSCoreParams?
  @objc deinit
}
public struct DefaultDataResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: walletverse_ios_sdk.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?, timeline: walletverse_ios_sdk.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DataResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let result: walletverse_ios_sdk.AResult<Value>
  public let timeline: walletverse_ios_sdk.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, result: walletverse_ios_sdk.AResult<Value>, timeline: walletverse_ios_sdk.Timeline = Timeline())
}
extension walletverse_ios_sdk.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.DataResponse {
  public func map<T>(_ transform: (Value) -> T) -> walletverse_ios_sdk.DataResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> walletverse_ios_sdk.DataResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> walletverse_ios_sdk.DataResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> walletverse_ios_sdk.DataResponse<Value> where E : Swift.Error
}
public struct DefaultDownloadResponse {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let error: Swift.Error?
  public let timeline: walletverse_ios_sdk.Timeline
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, error: Swift.Error?, timeline: walletverse_ios_sdk.Timeline = Timeline(), metrics: Swift.AnyObject? = nil)
}
public struct DownloadResponse<Value> {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let temporaryURL: Foundation.URL?
  public let destinationURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let result: walletverse_ios_sdk.AResult<Value>
  public let timeline: walletverse_ios_sdk.Timeline
  public var value: Value? {
    get
  }
  public var error: Swift.Error? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, temporaryURL: Foundation.URL?, destinationURL: Foundation.URL?, resumeData: Foundation.Data?, result: walletverse_ios_sdk.AResult<Value>, timeline: walletverse_ios_sdk.Timeline = Timeline())
}
extension walletverse_ios_sdk.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension walletverse_ios_sdk.DownloadResponse {
  public func map<T>(_ transform: (Value) -> T) -> walletverse_ios_sdk.DownloadResponse<T>
  public func flatMap<T>(_ transform: (Value) throws -> T) -> walletverse_ios_sdk.DownloadResponse<T>
  public func mapError<E>(_ transform: (Swift.Error) -> E) -> walletverse_ios_sdk.DownloadResponse<Value> where E : Swift.Error
  public func flatMapError<E>(_ transform: (Swift.Error) throws -> E) -> walletverse_ios_sdk.DownloadResponse<Value> where E : Swift.Error
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension walletverse_ios_sdk.DefaultDataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension walletverse_ios_sdk.DataResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension walletverse_ios_sdk.DefaultDownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
@available(iOS 10.0, macOS 10.12, tvOS 10.0, *)
extension walletverse_ios_sdk.DownloadResponse {
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
}
public struct SQLGenerationContext {
}
@_hasMissingDesignatedInitializers public class TableAlias : Swift.Hashable {
  public init(name: Swift.String? = nil)
  public subscript(selectable: walletverse_ios_sdk.SQLSelectable) -> walletverse_ios_sdk.SQLSelectable {
    get
  }
  public subscript(expression: walletverse_ios_sdk.SQLExpression) -> walletverse_ios_sdk.SQLExpression {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: walletverse_ios_sdk.TableAlias, rhs: walletverse_ios_sdk.TableAlias) -> Swift.Bool
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public struct DeserializeOptions : Swift.OptionSet {
  public let rawValue: Swift.Int
  public static let caseInsensitive: walletverse_ios_sdk.DeserializeOptions
  public static let defaultOptions: walletverse_ios_sdk.DeserializeOptions
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = walletverse_ios_sdk.DeserializeOptions
  public typealias Element = walletverse_ios_sdk.DeserializeOptions
  public typealias RawValue = Swift.Int
}
public enum DebugMode : Swift.Int {
  case verbose
  case debug
  case error
  case none
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct HandyJSONConfiguration {
  public static var debugMode: walletverse_ios_sdk.DebugMode {
    get
    set
  }
  public static var deserializeOptions: walletverse_ios_sdk.DeserializeOptions
}
public struct DatabaseDateComponents : walletverse_ios_sdk.DatabaseValueConvertible, walletverse_ios_sdk.StatementColumnConvertible {
  public enum Format : Swift.String {
    case YMD
    case YMD_HM
    case YMD_HMS
    case YMD_HMSS
    case HM
    case HMS
    case HMSS
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public let dateComponents: Foundation.DateComponents
  public let format: walletverse_ios_sdk.DatabaseDateComponents.Format
  public init(_ dateComponents: Foundation.DateComponents, format: walletverse_ios_sdk.DatabaseDateComponents.Format)
  public init(sqliteStatement: walletverse_ios_sdk.SQLiteStatement, index: Swift.Int32)
  public var databaseValue: walletverse_ios_sdk.DatabaseValue {
    get
  }
  public static func fromDatabaseValue(_ dbValue: walletverse_ios_sdk.DatabaseValue) -> walletverse_ios_sdk.DatabaseDateComponents?
}
public struct MultipartFormData {
  public enum FormDataProvider {
    case data(Foundation.Data)
    case file(Foundation.URL)
    case stream(Foundation.InputStream, Swift.UInt64)
  }
  public init(provider: walletverse_ios_sdk.MultipartFormData.FormDataProvider, name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public let provider: walletverse_ios_sdk.MultipartFormData.FormDataProvider
  public let name: Swift.String
  public let fileName: Swift.String?
  public let mimeType: Swift.String?
}
extension walletverse_ios_sdk.GDatabase {
  final public func makeSelectStatement(_ sql: Swift.String) throws -> walletverse_ios_sdk.SelectStatement
  final public func cachedSelectStatement(_ sql: Swift.String) throws -> walletverse_ios_sdk.SelectStatement
  final public func makeUpdateStatement(_ sql: Swift.String) throws -> walletverse_ios_sdk.UpdateStatement
  final public func cachedUpdateStatement(_ sql: Swift.String) throws -> walletverse_ios_sdk.UpdateStatement
  final public func execute(_ sql: Swift.String, arguments: walletverse_ios_sdk.StatementArguments? = nil) throws
}
public enum ValueScheduling {
  case mainQueue
  case onQueue(Dispatch.DispatchQueue, startImmediately: Swift.Bool)
  case unsafe(startImmediately: Swift.Bool)
}
public struct ValueObservation<Reducer> {
  public var requiresWriteAccess: Swift.Bool
  public var extent: walletverse_ios_sdk.GDatabase.TransactionObservationExtent
  public var scheduling: walletverse_ios_sdk.ValueScheduling
}
extension walletverse_ios_sdk.ValueObservation where Reducer : walletverse_ios_sdk.ValueReducer {
  public func start(in reader: walletverse_ios_sdk.DatabaseReader, onError: ((Swift.Error) -> Swift.Void)? = nil, onChange: @escaping (Reducer.Value) -> Swift.Void) throws -> walletverse_ios_sdk.TransactionObserver
}
extension walletverse_ios_sdk.ValueObservation {
  @available(*, deprecated, message: "Provide the reducer in a (Database) -> Reducer closure")
  public static func tracking(_ regions: walletverse_ios_sdk.DatabaseRegionConvertible..., reducer: Reducer) -> walletverse_ios_sdk.ValueObservation<Reducer>
  public static func tracking(_ regions: walletverse_ios_sdk.DatabaseRegionConvertible..., reducer: @escaping (walletverse_ios_sdk.GDatabase) throws -> Reducer) -> walletverse_ios_sdk.ValueObservation<Reducer>
  public static func tracking(_ regions: [walletverse_ios_sdk.DatabaseRegionConvertible], reducer: @escaping (walletverse_ios_sdk.GDatabase) throws -> Reducer) -> walletverse_ios_sdk.ValueObservation<Reducer>
}
extension walletverse_ios_sdk.ValueObservation where Reducer == () {
  public static func tracking<Value>(_ regions: walletverse_ios_sdk.DatabaseRegionConvertible..., fetch: @escaping (walletverse_ios_sdk.GDatabase) throws -> Value) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.RawValueReducer<Value>>
  public static func tracking<Value>(_ regions: [walletverse_ios_sdk.DatabaseRegionConvertible], fetch: @escaping (walletverse_ios_sdk.GDatabase) throws -> Value) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.RawValueReducer<Value>>
  @available(*, deprecated, message: "Use distinctUntilChanged() instead")
  public static func tracking<Value>(_ regions: walletverse_ios_sdk.DatabaseRegionConvertible..., fetchDistinct fetch: @escaping (walletverse_ios_sdk.GDatabase) throws -> Value) -> walletverse_ios_sdk.ValueObservation<walletverse_ios_sdk.DistinctUntilChangedValueReducer<walletverse_ios_sdk.RawValueReducer<Value>>> where Value : Swift.Equatable
}
open class EnumTransform<T> : walletverse_ios_sdk.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
extension Foundation.NSNumber : walletverse_ios_sdk._Transformable {}
extension Swift.String : walletverse_ios_sdk._Transformable {}
extension Swift.Int : walletverse_ios_sdk._Transformable {}
extension walletverse_ios_sdk.SQLLogicalBinaryOperator : Swift.Equatable {}
extension walletverse_ios_sdk.SQLLogicalBinaryOperator : Swift.Hashable {}
extension Swift.Optional : walletverse_ios_sdk._Transformable {}
extension walletverse_ios_sdk.GDatabase.ConflictResolution : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.ConflictResolution : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.ConflictResolution : Swift.RawRepresentable {}
extension walletverse_ios_sdk.DatabaseUUIDEncodingStrategy : Swift.Equatable {}
extension walletverse_ios_sdk.DatabaseUUIDEncodingStrategy : Swift.Hashable {}
extension walletverse_ios_sdk.NetworkReachabilityManager.ConnectionType : Swift.Equatable {}
extension walletverse_ios_sdk.NetworkReachabilityManager.ConnectionType : Swift.Hashable {}
extension walletverse_ios_sdk.JoinOperator : Swift.Equatable {}
extension walletverse_ios_sdk.JoinOperator : Swift.Hashable {}
extension walletverse_ios_sdk.HTTPMethod : Swift.Equatable {}
extension walletverse_ios_sdk.HTTPMethod : Swift.Hashable {}
extension walletverse_ios_sdk.HTTPMethod : Swift.RawRepresentable {}
extension walletverse_ios_sdk.URLEncoding.Destination : Swift.Equatable {}
extension walletverse_ios_sdk.URLEncoding.Destination : Swift.Hashable {}
extension walletverse_ios_sdk.URLEncoding.ArrayEncoding : Swift.Equatable {}
extension walletverse_ios_sdk.URLEncoding.ArrayEncoding : Swift.Hashable {}
extension walletverse_ios_sdk.URLEncoding.BoolEncoding : Swift.Equatable {}
extension walletverse_ios_sdk.URLEncoding.BoolEncoding : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.TransactionObservationExtent : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.TransactionObservationExtent : Swift.Hashable {}
extension walletverse_ios_sdk.DatabaseEvent.Kind : Swift.Equatable {}
extension walletverse_ios_sdk.DatabaseEvent.Kind : Swift.Hashable {}
extension walletverse_ios_sdk.DatabaseEvent.Kind : Swift.RawRepresentable {}
extension Foundation.NSString : walletverse_ios_sdk._Transformable {}
extension Foundation.NSArray : walletverse_ios_sdk._Transformable {}
extension Foundation.NSDictionary : walletverse_ios_sdk._Transformable {}
extension Swift.Bool : walletverse_ios_sdk._Transformable {}
extension Swift.Int8 : walletverse_ios_sdk._Transformable {}
extension Swift.Int16 : walletverse_ios_sdk._Transformable {}
extension Swift.Int32 : walletverse_ios_sdk._Transformable {}
extension Swift.Int64 : walletverse_ios_sdk._Transformable {}
extension Swift.UInt : walletverse_ios_sdk._Transformable {}
extension Swift.UInt8 : walletverse_ios_sdk._Transformable {}
extension Swift.UInt16 : walletverse_ios_sdk._Transformable {}
extension Swift.UInt32 : walletverse_ios_sdk._Transformable {}
extension Swift.UInt64 : walletverse_ios_sdk._Transformable {}
extension Swift.Double : walletverse_ios_sdk._Transformable {}
extension Swift.Float : walletverse_ios_sdk._Transformable {}
extension walletverse_ios_sdk.Currency : Swift.Equatable {}
extension walletverse_ios_sdk.Currency : Swift.Hashable {}
extension walletverse_ios_sdk.Currency : Swift.RawRepresentable {}
extension walletverse_ios_sdk.Language : Swift.Equatable {}
extension walletverse_ios_sdk.Language : Swift.Hashable {}
extension walletverse_ios_sdk.Language : Swift.RawRepresentable {}
extension walletverse_ios_sdk.Unit : Swift.Equatable {}
extension walletverse_ios_sdk.Unit : Swift.Hashable {}
extension walletverse_ios_sdk.Unit : Swift.RawRepresentable {}
extension walletverse_ios_sdk.Condition : Swift.Equatable {}
extension walletverse_ios_sdk.Condition : Swift.Hashable {}
extension walletverse_ios_sdk.Condition : Swift.RawRepresentable {}
extension walletverse_ios_sdk.Channel : Swift.Equatable {}
extension walletverse_ios_sdk.Channel : Swift.Hashable {}
extension walletverse_ios_sdk.Channel : Swift.RawRepresentable {}
extension walletverse_ios_sdk.GDatabase.CheckpointMode : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.CheckpointMode : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.CheckpointMode : Swift.RawRepresentable {}
extension walletverse_ios_sdk.GDatabase.ForeignKeyAction : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.ForeignKeyAction : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.ForeignKeyAction : Swift.RawRepresentable {}
extension walletverse_ios_sdk.GDatabase.TransactionCompletion : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.TransactionCompletion : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.TransactionKind : Swift.Equatable {}
extension walletverse_ios_sdk.GDatabase.TransactionKind : Swift.Hashable {}
extension walletverse_ios_sdk.GDatabase.TransactionKind : Swift.RawRepresentable {}
extension walletverse_ios_sdk.NetworkActivityChangeType : Swift.Equatable {}
extension walletverse_ios_sdk.NetworkActivityChangeType : Swift.Hashable {}
extension Swift.Set : walletverse_ios_sdk._Transformable {}
extension walletverse_ios_sdk.DebugMode : Swift.Equatable {}
extension walletverse_ios_sdk.DebugMode : Swift.Hashable {}
extension walletverse_ios_sdk.DebugMode : Swift.RawRepresentable {}
extension walletverse_ios_sdk.DatabaseDateComponents.Format : Swift.Equatable {}
extension walletverse_ios_sdk.DatabaseDateComponents.Format : Swift.Hashable {}
extension walletverse_ios_sdk.DatabaseDateComponents.Format : Swift.RawRepresentable {}
